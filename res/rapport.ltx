\documentclass{article}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[a4paper, margin=1in]{geometry}
\renewcommand{\familydefault}{\sfdefault}
\setlength{\parindent}{0pt}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{epigraph}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}
\lstset{
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  showstringspaces=false,
  breaklines=true,
  frame=single
}

\begin{document}

\begin{center}
	{\LARGE\textbf{INFO-F203 - Algorithmique 2 - Rapport}}\\[0.5em]
	\rule{0.9\textwidth}{1pt}
\end{center}

\vspace{5pt}
\begin{center}
	% \rowcolors{3}{green!25}{yellow!50}
	\begin{tabular}{ *3l }    \toprule
		\textbf{Prénom} & \textbf{Nom}      & \textbf{Matricule} \\\bottomrule
		Lucas           & Verbeiren         & 000591223          \\\bottomrule
		Ethan           & Van Ruyskensvelde & 000589640          \\\bottomrule
		%\hline
	\end{tabular}
\end{center}
\vspace{5pt}

\tableofcontents
\newpage

%-------------------------------------------------------------------


%TODO: pas oublier de dire qu'on a du restreindre le multicritère a un plus petit dataset

%TODO: remplacer l'adjectif basique (pas formel)

%TODO: parler du chargement des données
%TODO: parler du ballTree

%TODO: parler du fait que l'algo du CSA normal nous fait faire des switch inutiles

%TODO: mentionner le fait qu'on a considéré que le temps de changement entre deux trips est 0s

%TODO: parler du "limited walking optimization" et que ca a besoin que nos
%footpaths soient transitivement fermés + inégalité triangulaire ce qui en
%pratique n'est pas du tout le cas (voir https://arxiv.org/pdf/1703.05997 page 4)

\section{Introduction}

% TODO: check que cette intro reprend bien toutes les grandes sections (et pas
% en trop)
Les transports en commun jouent un rôle central dans la mobilité en Belgique,
où de nombreux citoyens dépendent quotidiennement des bus, trams, métros et
trains pour se déplacer. Déterminer l’itinéraire le plus rapide entre deux
arrêts constitue un enjeu crucial. Ce rapport présente nos implémentations de
deux algorithmes de plus court chemin prenant en compte les trajets
multimodaux, i.e. pouvant combiner différents modes de transport en commun.
Ceux-ci prennent également en compte, des segments de marche à pied entre les
arrêts, mais ne tiennent pas compte des temps de transfert (d'un véhicule à
l'autre, ou transition entre véhicule et marche). Les deux algorithmes sont
regroupés sous le nom de \textit{Connection Scan Algorithm (CSA)} et sont
présentés dans \cite{ConnectionScanAlgorithmLong:2017}. Dans un premier temps,
nous expliquons les notions générales associées aux problèmes de plus court
chemin dans le contexte des transports en commun. Dans un deuxième temps, nous
détaillons le fonctionnement et notre implémentation du CSA de base qui
optimise seulement le temps d'arrivée (\textit{earliest arrival CSA}). Dans un
troisième temps, nous présentons une version fortement insipirée du
\textit{Pareto Connection Scan profile algorithm}. Ce dernier peut prendre en
considération d'autres critères, en plus du temps d'arrivée, et optimise
ceux-ci au sens pareto.

%-------------------------------------------------------------------

% TODO: find a better title
\section{Définitions générales}

\begin{itemize}

	\item \textbf{Arrêt (Stop)}~: Arrêt pour n'importe quel mode de transport en commun, e.g. arrêt de Bus.

	\item \textbf{Connexion}~: Un trajet direct entre deux arrêts effectué par un
	      véhicule, avec une heure de départ et d'arrivée ainsi qu'un point de
	      départ et d'arrivée.

	\item \textbf{Chemin (à pied)}~: Un chemin direct entre deux arrêts pouvant être effectué à pied, avec un point de départ et d'arrivée.

	\item \textbf{Mouvement}~: Regroupe connexion et chemin à pied.

	\item \textbf{Trip}~: Une instance d'un véhicule parcourant un trajet.

	\item \textbf{Horaire (Timetable)}~\cite{ConnectionScanAlgorithmLong:2017} : L'horaire fait partie des paramètres des deux algorithmes.
	      % TODO: faire qqch montrer que c'est une citation traduite
	      Un horaire est un quadruplet $(\mathcal{S}, \mathcal{C}, \mathcal{T} , \mathcal{F})$
	      d'arrêts (stops) $\mathcal{S}$, de connexions (connections) $\mathcal{C}$, de trips $\mathcal{T}$, et de chemin à pieds (footpaths) $\mathcal{F}$.

\end{itemize}


%-------------------------------------------------------------------

\section{Principales classes et méthodes utilisées dans le programme java}

\begin{itemize}

	% TODO: bizarre comment on alterne entre pas-phrase et phrase

	\item \textbf{Coord}~: représente des coordonnées géographiques. Permet de calculer la distance du grand cercle séparant séparant deux instances de \texttt{Coord} via la méthode \texttt{distanceTo()}. Pour ce faire, cette dernière utilise la formule de \texttt{Haversine} \cite{haversineFormula}.

	\item \textbf{Stop}~: représente un arrêt. Cette classe contient essentiellement l’identifiant, le nom et les coordonnées géographiques de l'arrêt.

	\item \textbf{Connection}~: classe représentant une connexion.

	\item \textbf{Footpath}~: représente un chemin à pied. Celui-ci possède une
	      distance ainsi qu'une durée de trajet. La durée de trajet est calculée
	      en supposant que l'utilisateur marche à une vitesse de 5~km/h.

	\item \textbf{Movement}~: représente un mouvement, une interface pour \texttt{Footpath} et \texttt{Connection}.

	\item \textbf{BallTree}~: % TODO

	      % TODO: is this one really necessary ?
	\item \textbf{TransportType}~: enumérée contenant les différents moyens de déplacement.

	\item \textbf{Solver}~: classe regroupant la logique nécessaire pour le CSA de base. Les méthodes essentielles :

	      \begin{itemize}
		      \item \texttt{solve()}~: implémentation de l'algorithme CSA de base.

		            % TODO: might wanna split this in two
		      \item \texttt{reconstructSolution()} et \texttt{printInstructions()}~: reconstruisent le chemin optimal et affichent les instructions de trajet.

		      \item \texttt{genFootpaths()} génère les chemins à pied en ne gardant que ceux dont la longueur est inférieur ou égale celle précisée, à l'aide de la classe \texttt{BallTree}.
	      \end{itemize}

	\item \textbf{MultiCritSolver}~: classe regroupant la logique nécessaire pour le CSA multicritère. Les méthodes essentielles :

	      \begin{itemize}
		      \item \texttt{solve()}~: implémentation de l'algorithme CSA multicritère.

		      \item \texttt{displayJourney()}~: affiche les instructions de trajet.

		      \item \texttt{genFootpaths()} génère les chemins à pied en ne gardant que ceux dont la longueur est inférieur ou égale celle précisée, à l'aide de la classe \texttt{BallTree}.
	      \end{itemize}

	\item \textbf{AbstractSolver}~: Regroupe les fonctions communes à Solver et AbstractSolver.

	\item \textbf{Main}~: % TODO

\end{itemize}

%-------------------------------------------------------------------

\section{Chargement des données GTFS}


Avant que nous puissions effectuer des requêtes de plus court chemin à l'aide de nos algorithmes, nous devons d'abord charger les données nécessaires dans les objets représentant les deux algorithmes, i.e. \texttt{Solver} et \texttt{MultiCritSolver}.
Ces données, conformes au format \texttt{GTFS} (General Transit Feed Specification), contiennent toutes les informations liées aux arrêts, trajets, horaires et lignes de transport.\newline

Les données GTFS utilisées dans notre programme sont les données publiques fournies par \texttt{DE LIJN}, la \texttt{STIB}, le \texttt{TEC} et la \texttt{SNCB}.\newline

Le processus de chargement s'effectue en trois grandes étapes :
\begin{enumerate}

	\item Création, pour chaque opérateur, d’un objet \texttt{CsvSet} contenant les chemins vers les fichiers \texttt{csv} correspondants.

	\item Création de l'objet \texttt{Data}, via la méthode statique \texttt{Data.loadFromCSVs(CsvSet... csvSets)} qui appellera la méthode \texttt{loadOneCsvSet}, qui pour chaque \texttt{CsvSet}, traitera les fichiers suivants :

	      % TODO: expliquer comment on charge les données (probablement réutiliser ce qu'il y a dans les paragraphes en dessous)
	      % TODO: surtout pas oublier de dire qu'on doit trier les connections par heure de départ
	      \begin{itemize}
		      \item \textbf{\texttt{stops.csv}} : contient les identifiants, noms et coordonnées géographiques des arrêts. Chaque arrêt est stocké dans une structure \texttt{Stop}, identifiée par son \texttt{stop\_id}.

		      \item \textbf{\texttt{trips.csv}} : associe chaque \texttt{trip\_id} à une \texttt{route\_id}, représentant un parcours complet effectué par un véhicule.

		      \item \textbf{\texttt{routes.csv}} : fournit le nom de chaque ligne, ainsi que le type de transport, et est identifiable grâce au \texttt{route\_id}. Ces données sont enregistrées dans une structure \texttt{RouteInfo} contenant toutes ces informations.

		      \item \textbf{\texttt{stop\_times.csv}} : liste, pour chaque \texttt{trip}, les arrêts desservis dans l’ordre (\texttt{stop\_sequence}), avec l’heure de départ à chaque arrêt. Nous convertissons les horaires en secondes depuis minuit pour simplifier les comparaisons.
	      \end{itemize}

	      La méthode \texttt{loadOneCsvSet} commence par regrouper les entrées par \texttt{trip\_id}, puis trie chacun de ces groupes par \texttt{stop\_sequence}, pour ensuite génèrer les \textbf{connexions}, c’est-à-dire les trajets directs entre deux arrêts consécutifs d’un même trajet avec :
	      \begin{itemize}
		      \item l’identifiant du trajet (\texttt{trip\_id}),
		      \item la ligne de transport concernée (\texttt{RouteInfo}),
		      \item l’arrêt de départ et d’arrivée (\texttt{Stop}),
		      \item le temps de départ et le temps d’arrivée (en secondes).
	      \end{itemize}

	      Une fois toutes les connexions générées à partir des données GTFS des
	      différents opérateurs, nous trions toutes les connexions par heure de départ
	      croissante, les deux algorithmes nécessitent que les connections soient triées
	      ainsi. Toutefois, ceux-ci les parcourent dans des ordres opposés.\ % parler du tri, de sa complexité temporelle


	\item Instanciation du \texttt{Solver} et/ou du \texttt{MultiCritSolver} à l’aide de l’objet \texttt{Data} (passé aux constructeurs).
	      Le constructeur \texttt{Solver} et de \texttt{MultiCritSolver} appellent leur méthode \texttt{genFootpaths} pour générer les chemins
	      à pied sur base des instances de \texttt{Stop}. % TODO: phrase bof

\end{enumerate}

\subsection{Construction des chemins à pied (\texttt{Footpath})}

% voir page 4
% TODO: expliquer pourquoi c'est nécessaire
Les algorithmes CSA~\cite{ConnectionScanAlgorithmLong:2017} requièrent que le graphe des chemins à pied
\begin{itemize}

	\item soit transitivement fermé

	\item satisfasse l'inégalité triangulaire

\end{itemize}

Une solution simple, qui respecte ces deux critères, consiste à parcourir les
arrêts à l’aide de deux boucles for imbriquées, en considérant chaque paire de
\texttt{Stop} appartenant à deux chemins différents (un dans chaque sens).
Cette approche présente une complexité spatiale et temporelle en $\Theta(n^2)$,
où $n$ est le nombre d'arrêts, ce qui entraîne des durées d’exécution
particulièrement longue.

% TODO: reformuler ceci
Pour les raisons suivantes :
\begin{itemize}
	\item très grand nombre d'arrêts
	      dans nos données de test,
	\item le grand nombre de chemins extrêmement
	      longs, qu'aucun utiliateur ne voudrait emprunté en pratique puique certain
	      traversent la belgique entière,
	\item le fait que plus un chemin est long,
	      moins il a de chance d'être le meilleur trajet reliant son arrêt de départ à
	      son arrivée (dù à la vitesse de marche très lente par rapport aux autre moyens
	      de tranport),
\end{itemize}
nous offrons la possibilité de réduire le nombre de chemins à pied en ne tenant
pas compte de ceux dépassant une certaine distance donnée \texttt{maxDistKm}.
Le graphe n'est alors plus transitivement fermé, les algorithmes ne donnent
plus la/les solutions optimales. Dans la suite du rapport nous supposerons que
\texttt{maxDistKm} est suffisament grand pour ne pas (trop) impacter
l'optimalité de l'algorithme. Nous pouvons ajuster cette distance via le
paramètre \texttt{maxDistKm} des méthodes \texttt{genFootpaths} de
\texttt{Solver} et \texttt{MultiCritSolver}, permettant de créer les instances
de \texttt{Footpaths}.

Il existe deux implémentations distinctes de \texttt{genFootpaths} car \texttt{Solver} et \texttt{MultiCritSolver} stockent les chemins différemment :
\begin{itemize}

	\item \texttt{Solver} requiert une map associant chaque \texttt{stopId} à la liste des \texttt{Footpath} partant de cet arrêt.

	\item \texttt{MultiCritSolver} requiert une map associant chaque \texttt{stopId} à la liste des \texttt{Footpath} arrivant à cet arrêt.

\end{itemize}

Malgré cette différence, le procédé de construction des chemins reste
identique: Puique nous limitons les chemins à un certain rayon, nous utilisons
un \texttt{BallTree}, une structure permettant d'effectuer des recherches de
voisinage efficaces dans un espace à plusieurs dimensions (dans notre cas, deux
: latitude/longitude).
L'algorithme de génération s'effectue ainsi :
\begin{itemize}

	\item Initialiser un \texttt{BallTree} avec tous les arrêts.

	\item Pour chaque arrêt source, chercher tous les arrêts voisins dans un rayon \texttt{maxDistKm}.
	      Pour chaque voisin trouvé, créer l'objet \texttt{Footpath} avec les deux arrêts et l’ajouter à la map liant les arrêts de départ ou d'arrivée aux instances de \texttt{Footpath} (en fonction de \texttt{Solver} ou \texttt{MultiCritSolver}).

\end{itemize}

% TODO: Expliquer comment fonctionne la recherche et la création du BallTree 
% cite this https://www.cs.cornell.edu/courses/cs4780/2018fa/lectures/lecturenote16.html and explain what we changed

% TODO: expliquer en quoi consiste la recherche naive des voisins
% WARN: BallTree is not in O(n) in worst case, I fucked-up very bad
% TODO: fix this huge mistake (worst case time complexity)
% L'avantage du \texttt{BallTree} réside dans sa complexité temporelle avantageuse pour la recherche des arrêts voisins d'un arrêt donné dans un certain rayon :
% alors qu’une recherche naïve des voisins aurait une complexité en $\mathcal{O}(n^2)$, celle du \texttt{BallTree} est en $\mathcal{O}(n)$ dans le pire des cas, grâce à sa structure hiérarchique.
% Cette amélioration permet de rendre l’étape de génération des chemins à pied plus rapide.\\

\subsection{Complexité du chargement}
% TODO: complexité temporelle (balltree + tim sort)
% TODO: complexité spatiale

%-------------------------------------------------------------------

\section{CSA de base (arrivée la plus tôt)}

% TODO: expliquer la big flaw du CSA basique, comme on update seulement les
% footpaths directement connectés au connexions scannées, (on progpage pas plus
% qu'un seul footpath, jamais on propagera 2+ footpaths plus loin), ca repose
% sur le fait qu'on ne marche jamais 2 fois d'affilé. Cependant, cette
% condition est respectée uniquement si on a la fermeture transitive du graphe
% des footpaths, ce qui en pratique n'est pas le cas.

Le CSA de base permet de résoudre le problème suivant :

\begin{quote}
	Étant donné l'horaire, un arrêt de départ $pDep$, un arrêt d'arrivée
	$pArr$, et un temps de départ $tDep$, renvoyer les différents segments du
	trajets arrivant le plus tôt possible en $pArr$ en partant de $pDep$ en
	$tDep$.
\end{quote}

Notre version du CSA de base accepte des noms d’arrêts, qui ne sont pas
forcément uniques, au lieu des identifiants uniques. Elle considère tous les
arrêts correspondant au nom de départ et au nom d’arrivée, supposés proches les
uns des autres, et calcule le plus court trajet parmi ceux qui partent d’un des
arrêts de départ possibles et arrivent à un des arrêts d’arrivée possibles.

\subsection{Structure de données}

Notre implémentation utilise principalement des \texttt{HashMap}, des
\texttt{ArrayList} et une \texttt{Stack}.

\begin{itemize}

	\item \texttt{HashMap<String, Stop> stopIdToStop}~: permet d’associer
	      l'identifiant d'un arrêt à l'objet \texttt{Stop}.

	\item \texttt{HashMap<String, List<Footpath>> stopIdToOutgoingFootpaths}~:
	      associe à chaque arrêt une liste contenant les différentes instances de
	      \texttt{Footpath} qui démarrent de cet arrêt.

	\item \texttt{List<Connection> connections}~: liste des connexions triée
	      par heure de départ croissante.

	\item \texttt{Map<String, BestKnownEntry> bestKnown}~: permet de garder à
	      jour le meilleur temps d’arrivée connu pour chaque arrêt, ainsi que le
	      denier mouvement (trajet ou marche) qui nous y mène. Pour chaque arrêt,
	      si son identifiant unique est \texttt{stopId}, alors \texttt{bestKnown}
	      à l'entrée \texttt{stopId} peut se lire comme "nous parvenons en
	      \texttt{stopId} à l'instant \texttt{bestKnown.get(stopId).getTArr()} en
	      empruntant un trajet se terminant par
	      \texttt{bestKnown.get(stopId).getMovement()}".

	\item \texttt{Stack<BestKnownEntry>}~: utilisée pour reconstruire le chemin
	      optimal, afin d'afficher les instructions dans l’ordre.

\end{itemize}

%-------------------------------------------------------------------

\subsection{Description de l'algorithme}

Dans cette sous-section, nous définissons d'abord les différentes notions
cruciales pour comprendre l'algorithme \texttt{CSA de base (arrivée la plus
	tôt)}, puis nous détaillons son fonctionnement.

%TODO: séparateur pour dire que ca c'est les notions importantes

\begin{itemize}

	\item Une connection est dite \textit{atteignable} si nous sommes en
	      mesures de nous trouver à son arrêt de départ au moment auquel celle-ci
	      ne démarre, i.e. $bestKnown_{tArr}(c_{pDep}) \leq c_{tDep}$.

	      %TODO: vérifier que ce truc est nécessaire à définir
	\item Un mouvement $m1$ est plus rapide qu'un autre mouvement $m2$ si $m1$
	      et $m2$ ont la même destination et $m1$ atteint celle-ci avant $m2$.

	\item Calcul du temps d'arrivé d'un chemin à pied : $f_{tArr} = f_{tDep} +
		      f_{travelTime}$ où $f_{tDep}$ correspond au meilleur temps connu pour
	      se rendre au point de départ de $f$, i.e. $f_{pDep}$.

\end{itemize}


%TODO: séparateur pour dire que ca c'est l'algo lui-meme


\begin{enumerate}

	\item \textbf{Critère de départ}~: \label{item:criteredepart}
	      \cite{ConnectionScanAlgorithmLong:2017} Aucune connection partant avant
	      le temps de départ demandé n'est \textit{atteignable}, il est donc
	      inutile de prendre celles-ci en compte dans la suite de l'algorithme.
	      La méthode\\ \texttt{getEarliestReachableConnectionIdx} détermine
	      l'indice de la première connection dont l’heure de départ est supérieur
	      ou égale à l’heure de départ demandée à l'aide d'une recherche
	      dichotomique dans \texttt{connections}.

	\item \textbf{Initialisation}~: Pour chaque arrêt de départ, nous
	      initialisons \texttt{bestKnown} aux entrées correspondantes comme suit:
	      \begin{itemize}
		      \item Le temps d'arrivée \texttt{tArr = tDep} : Nous pouvons nous y rendre
		            instantanément.
		      \item Le mouvement emprunté \texttt{movement = null} : Aucun mouvement n'est nécessaire pour s'y rendre.
	      \end{itemize}

	      Nous explorons également chaque chemin accessible à pied $f$ partant
	      de ces arrêts de départ. Si $f$ permet d'atteindre $f_{pArr}$ plus
	      rapidement que le meilleur temps connu pour atteindre celui-ci, i.e.
	      $f_{tArr} < bestKnown_{tArr}(f_{pArr})$, alors nous mettons à jour le
	      temps d'arrivée dans \texttt{bestKnown} à l'entrée $f_{pArr}$
	      comme-suit:
	      \begin{itemize}
		      \item Le temps d'arrivée \texttt{tArr =} $f_{tArr}$
		      \item Le mouvement emprunté \texttt{movement =} $f$
	      \end{itemize}

	\item \textbf{Scan des connections et chemins}~: Nous traitons les
	      \texttt{Connection} de \texttt{connections} itérativement, en ne tenant
	      compte que de celles partant à notre heure de départ ou après, i.e. à
	      partir de l'indice trouvé a
	      l'étape~\hyperref[item:criteredepart]{\textbf{Critère de départ}}.
	      Appelons la connection en cours de traitement $c$. (Pour rappelle, les
	      connexions sont triées par ordre croissant d’heure de départ, nous les
	      scannons donc dans ce même ordre) :

	      \begin{itemize}

		      \item si $c$ est \textit{atteignable}~,

		      \item et si $c$ permet d’arriver plus tôt à son arrêt d'arrivée $c_{pDep}$ que le meilleur temps connu pour s'y rendre à cette étape de l'algorithme~: $c_{tArr} < bestKnown_{tArr}(c_{pArr})$

		      \item Alors, nous mettons à jour l'entrée de \texttt{bestKnown}
		            correspondant à l’arrêt $c_{pArr}$ car nous venons de trouver
		            un moyen de s'y rendre plus rapidement :
		            \begin{itemize}
			            \item Le temps d'arrivée \texttt{tArr =} $c_{tArr}$
			            \item Le mouvement emprunté \texttt{movement =} $c$
		            \end{itemize}

		            Ensuite, pour chaque chemin $f$ sortant de $c_{pArr}$, nous
		            calculons le temps d'arrivée de ce chemin
		            $f_{tArr} = c_{tArr} + f_{travelTime}$.

		            Nous vérifions si $f$ nous permet d'atteindre son arrêt
		            d'arrivée $f_{pArr}$ plus rapidement que le meilleur temps
		            connu à cette étape de l'algorithme, i.e. $f_{tArr} <
			            bestKnown_{tArr}(f_{pArr})$
		            Si c'est le cas, nous mettons à jour bestKnown correspondant à $f_{pArr}$.

		            % TODO: expliquer pourquoi on a le droit de restreindre
		            % l'update les footpaths à seulement quand on a trouvé une
		            % meilleur connection (expliqué a la page 8: "Limited
		            % Walking")

	      \end{itemize}

	\item \textbf{Critère d'arrêt}~: Selon
	      \cite{ConnectionScanAlgorithmLong:2017}, nous pouvons arrêter
	      l'itération sur les connections dès que nous scannons une connection
	      $c$ telle que $c_{tDep} >= bestKnown_{tArr}(pArr)$.

	      Supposons $c$, la première connection telle que $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, comme $c_{tDep} < c_{tArr}$, si $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, alors par transitivé, nous avons que
	      $bestKnown_{tArr}(pArr) < c_{tArr}$. $c$ ne peut donc pas permettre
	      d'améliorer \texttt{bestKnown}.

	      Étant donné que nous scannons les connections par odre croissant, ces inégalité reste vraie pour toutes les connections après $c$.

	      Puisque notre algorithme supporte plusieurs arrêts d'arrivée avec le
	      même nom, et doit choissir celui auquel nous parvenons le plus
	      rapidement, nous devons tester cette inégalité pour chaque arrêt dont
	      le nom correspond au nom de la destination finale. Dès que cette
	      inégalité n'est plus vraie, nous pouvons arrêter le scan des
	      connections.

	\item \textbf{Recherche du meilleur arrêt d'arrivée}~: Puisque plusieurs
	      arrêts peuvent co-exister avec le même nom et que notre algorithme
	      prend en entrée un \textit{nom d'arrêt} de départ et d'arrivée et non
	      des identifiants d'arrêts uniques, nous cherchons l'identifiant unique
	      de l'arrêt d'arrivée auquel nous parvenons le plus rapidement, et ce
	      via une simple recherche linéaire.

	\item \textbf{Reconstruction}~: Une fois $pArr$ le meilleur arrêt d'arrivée
	      trouvé, nous reconstruisons, à partir de $pArr$, le trajet final
	      (chaque mouvement composant celui-ci) partant de $pDep$ en $tDep$ et
	      arrivant en $pArr$ le plus rapidement. Il s'agit d'un parcours en
	      postordre car nous le reconstruisons en partant du point d'arrivée.
	      Pour ce faire, nous utilisons donc une stack appelée
	      \texttt{finalPath}. Chaque `BestKnownEntry` (le mouvement et son temps
	      d'arrivée) est empilée sur \texttt{finalPath}. Une autre fonction
	      dépile ensuite la stack tout en affichant les différents segments du
	      trajet.

	      Comme pour les arrêts d'arrivée, plusieurs arrêts de départ
	      pourraient avoir un nom correspondant à celui entré par
	      l'utilisateur. Le cas de base de notre parcours en postordre est donc
	      le cas où le stop que nous regardons actuellement est un des
	      potentiels arrêts de départ.

	      \begin{algorithm}[H]
		      \DontPrintSemicolon
		      \SetAlgoLined

		      initialiser stack $finalPath$ \;
		      $currentStopId \leftarrow pArrIdEarliest$ \;

		      \While{$currentStopId \notin pDepIds$}{
			      $currentEntry \leftarrow bestKnown[currentStopId]$ \;

			      empiler $currentEntry$ dans $finalPath$ \;
			      $currentStopId \leftarrow$ identifiant de l’arrêt de départ du mouvement de $currentEntry$ \;
		      }

		      \caption{Reconstruction du chemin optimal à partir de \texttt{bestKnown}}
	      \end{algorithm}

	      %TODO: parler de l'éventuelle dernière étape: print le trajet en dépilant

\end{enumerate}

%-------------------------------------------------------------------

\subsection{Preuve d'exactitude}

Dans cette sous-section, nous montrons que l'algorihme \texttt{CSA de base
	(arrivée la plus tôt)} fournit une solution optimal (pour rappelle, en
supposant que \texttt{maxDistKm} soit suffisament grand).

Nous basons notre preuve sur ~\cite{critèresAlgoPlusCourtCheminDAG}, selon
lequel, pour résoudre le problème du plus court chemin (\textit{chemin} au sens
théorie des graphes, correspondant donc à un \textit{trajet} dans notre cas, à
ne pas confondre avec les chemins au sens instances de \texttt{Footpath}) dans
un graphe dirigé acyclique, notre algorithme doit :
\label{item:dagcriteresshortestpath}
\begin{itemize}

	\item Examiner les sommets dans un ordre topologique,

	\item{} Pour chaque sommet v, on assigne la valeur
	      $d(v) \leftarrow \min_{e=(u,v) \in \mathcal{E}} \{ d(u) + w(e) \}$

\end{itemize}

% ----- dirigé -----

D'abord, il est évident que notre graphe est dirigé. En effet, sans même tenir
compte des horaires, l'existence d'une connexion n'implique pas qu'il existe
une autre connexion effectuant le même trajet dans l'autre sens.\\

% ----- acyclic -----

Ensuite, montrons que ce graphe est acyclique, comme cela est mentionné dans
\cite{ConnectionScanAlgorithmShort}. Par l'absurde, supposons qu'il existe un
cycle formé de mouvements (formé de connexions et/ou chemins à pied) $m_1, m_2,
	\dots, m_n$ tels que:
\begin{itemize}

	\item $m_{n_{pArr}} = m_{1_{pArr}}$ : $m_n$ revient au point de départ du
	      cycle.

	\item L'ensemble de ces mouvements forme un chemin valide dans le réseau
	      (chaque connection est atteignable).

	\item Le départ de $m_1$ se fait à l'instant $t$ et l'arrivée de $m_n$ se
	      produit à l'instant $t'$.

\end{itemize}

%TODO: enlever les répétitions de "puisque" à chaque paragraphe

Puisque chaque connection peut être emprunté seulement si celle-ci est
atteignable, et que chaque movement prend un temps strictement positif, cela
implique que chaque transition de mouvement augmente strictement le temps. Donc
$t' > t$, ce qui contredit le fait que $m_1, \dots, m_n$ forme un cycle, car
certes, $m_n$ revient à l'arrêt de départ de $m_1$, mais du temps s'est écoulé
entre le moment auquel nous démarrons le cycle et celui auquel nous arrivons du
cycle. Certaines connexions qui étaient atteignable avant d'emprunter le cycle
ne sont donc potentiellement plus atteignables. \\

% -----------------------------

Étant donné que nous avons un graphe dirigé acyclique, il nous suffit de
vérifier que le CSA respecte bien les
deux~\hyperref[item:dagcriteresshortestpath]{critères pour les algorithmes de
	plus court chemin dans un DAG}:

\begin{itemize}

	\item \textbf{Ordre topologique}~: \cite{tudelft} Puisque notre graphe est
	      un DAG, il existe forcément au moins un ordre topologique. Montrons
	      maintenant que parcourir les connexions par ordre de départ croissant
	      constitue un ordre topologique. Par l'absurde, supposons qu'il ne
	      s'agisse pas d'un ordre topologique. Cela signifie qu'il existe un
	      trajet $m_1, \dots, m_i$, et un autre trajet $m_i, \dot, m_n$ nous
	      permettant de reprendre $m_1$ au même moment que la fois précédente.
	      Clairement, cela entre directement en contradiction avec le fait que
	      les durées des mouvements sont strictement positives.

	\item \textbf{Relaxation des arêtes}~: Le second point est trivial, cela
	      correspond exactement à l'étape de relaxation des mouvements et de
	      mise à jour de \texttt{bestKnown}.

\end{itemize}

%-------------------------------------------------------------------

\subsection{Complexité}

% TODO complexité temporelle O(n - m), pas exactement à cause des footpaths ou
% n = nombre de connections qui partent apres tdep, 
% m = nombre de connections qui ne seront pas scannées à cause du stopping criterion

% TODO complexité spatiale


%-------------------------------------------------------------------

\section{CSA multicritère}

% TODO: check le casing de $x$ et $y$

% TODO: petite partie qui décrit le probleme du multicritère, en quoi ca
% consiste un peu comme l'intro du CSA normale, il faut au moins dire qu'on
% part de pDep en tDep et qu'on arrive en pArr

% TODO: "qui pourrait laisser penser" pas fou

% TODO: par sûr du "au sens pareto"

Dans cette section, nous présentons puis réfutons une idée intuitive selon
laquelle une simple modification du CSA basique permettrait d’en faire un
algorithme multicritère. Nous présentons ensuite notre implémentation modifiée
de l'algorithme mcpCSA qui peut prendre en compte plusieurs critères et
optimise ceux-ci au sens pareto.\\


Dans le CSA basique, la fonction de coût, utilisée pour comparer deux trajets
lors de la mise à jour de \texttt{bestKnown}, est définie par :
\[
	\operatorname{cost} : \mathbb{T} \to \mathbb{T}, \quad t \mapsto t
\]
C'est à dire que le cout est directemment le temps d'arrivée.\\

%TODO: pas convaincu par le C "complexe" ni par le fait qu'on passe de \mathbb{T} à \mathbb{C}

L'idée intuitive consiste alors à remplacer la fonction de coût par une
fonction déterminée par l'utilisateur, prenant en paramètre les valeurs pour
les critères supportés par le programme, e.g. le nombre de mouvements effectués
en trams :
\[
	\text{cost} : \mathbb{X}_1 \times \cdots \times \mathbb{X}_n \to
	\mathbb{C}, \quad (x_1, \ldots, x_n) \mapsto c
\] \label{item:CostMultiCriteria}
où
\begin{itemize}

	\item $x_1, \ldots, x_n$ représentent des valeurs pour les critères choisis
	      par l'utilisateur, e.g. temps d'arrivée, nombre de connections en tram,
	      nombre de chemins à pied.

	\item $c \in \mathbb{C}$ est le coût global calculé selon la fonction
	      définie par l'utilisateur.

\end{itemize}

Nous conservons alors dans \texttt{bestKnown}, pour chaque arrêt, les $x_1,
	\ldots, x_n$ correspondant au trajet menant à cet arrêt et minimisant le coût.

Afin d'effectuer la comparaison entre deux trajets $X, Y$ pour déterminer si
$X$ a un meilleur cout que $Y$, il suffit de vérifier :
\[
	\operatorname{cost}(x_1, \dots, x_n) < \operatorname{cost}(y_1, \dots, y_n)
\]

Malheureusement, cette approche intuitive ne fonctionne pas. Voici un
contre-exemple :

\begin{center}
	\begin{tikzpicture}[->, >=Stealth, node distance=1cm, thick]

		% Nodes
		\node[circle, draw] (x) at (0,2)  {$x$};
		\node[circle, draw] (w) at (0,0)  {$w$};
		\node[circle, draw] (y) at (3,2)  {$y$};
		\node[circle, draw] (z) at (5.5,2)  {$z$};

		% Edges
		\draw (x) -- (y) node[midway, xshift=25pt, yshift=6pt] {$t2$};
		\draw (x) -- (y) node[midway, xshift=-27pt, yshift=6pt] {$t1$};
		\draw (x) -- (y) node[midway, xshift=-3pt, yshift=5pt] {$c1$};

		\draw (w) -- (y) node[midway, xshift=27pt, yshift=11pt] {$t4$};
		\draw (w) -- (y) node[midway, xshift=-33pt, yshift=-14pt] {$t3$};
		\draw (w) -- (y) node[midway, xshift=3pt, yshift=-3pt] {$c3$};

		\draw (y) -- (z) node[midway, xshift=-22pt, yshift=6pt] {$t2$};
		\draw (y) -- (z) node[midway, xshift=0pt, yshift=6pt] {$c2$};

	\end{tikzpicture}
\end{center}

% TODO: qqch pour expliquer ce qui est quoi dans ce graphe, expliquer que t1<t2<t3<t4

Notons pour toute connection $c$:
\[
	\operatorname{cost}(c) = \operatorname{cost}(pDep \rightarrow c_{pDep} + c)
\]

Autrement dit, le coût
d'une connexion $c$ correspond au coût du trajet composé du meilleur itinéraire
partant d'un point de départ spécifié par l’utilisateur, atteignant $c_{pDep}$,
puis empruntant la connexion $c$.\\

% TODO: fix les temps pour qu'il match le graphe
Étant donné que $c1_{tDep} < c2_{tDep} < c3_{tdep}$, nous scannons d'abord $c1$.
% TODO: améliorer cette phrase
Une fois le scan de $c1$ terminé :
\[
	\texttt{bestKnown}_{cost}(y) \leq \operatorname{cost}(c1)
\]

Il en va de même pour le scan de $c2$ :
\[
	\texttt{bestKnown}_{cost}(z) \leq \operatorname{cost}(c2)
\]

Et enfin, nous scannons la connection $c3$.
Supposons que:
\[
	\texttt{bestKnown}_{cost}(z) > \operatorname{cost}(c3)
\]

Nous remplaçons alors les $x_1, \dots, x_n$ (aini que l'instance de
\texttt{Movement}) dans \texttt{bestKnown} pour l'arrêt $y$.

Cette décision rend notre solution partielle invalide, car en prenant $c3$ qui
arrive en $y$ à l'instant $t4$, nous ne pouvons plus atteindre $c2$ qui part de
$y$ en $t2$.\\

% TODO: check si ca serait pas mieux d'expliquer ca avant de mettre le
% contre-exemple 
% TODO: pourquoi on repete le fait que c'et le seul a la fin ?
Formellement, cela est dû fait que seul le critère de temps d'arrivée le plus
tôt respecte \textit{la condition d'échangeabilité préfixe} :
\cite{ConnectionScanAccelerated} Soit $s_1, s_2, \dots, s_n$ un trajet optimal
$A@tDep \rightarrow B$, i.e. partant de $A$ en $tDep$ et arrivant en $B$.
Considérons un préfixe quelconque $s_1, \dots, s_i$, un trajet complet arrivant
en $C$. Remplacer le préfixe par un autre trajet optimal $A@tDep \rightarrow C$
doit donner un autre trajet optimal $A@tDep \rightarrow B$. Cependant, seul le
critère d'arrivée le plus tôt satisfait cette propriété, les autres critères ne
garantissent pas que la connexion que nous avions prévu de prendre en $C$ soit
toujours atteignable avec le nouveau préfixe.\\

Similairement nous pouvons définir la \textit{condition d'échangeabilité
	suffixe} \cite{ConnectionScanAccelerated} : Soit $s_1, \dots, s_n$ un trajet
optimal $A@\tau \rightarrow B$. Considérons n'importe quel suffixe $s_i, \dots,
	s_n$ qui est un trajet complet partant de $C$ en $\tau'$. Remplacer ce suffixe
par un autre trajet optimal $C@\tau' \rightarrow B$ doit donner un autre trajet
optimal.\\

Étant donné que cette seconde condition est maintenue par les
~\hyperref[item:CostMultiCriteria]{fonctions de coût multicritères}, nous en
tirons avantage pour notre algorithme en construisant les trajets à partir du
point d'arrivée \cite{ConnectionScanAccelerated}.\\

% TODO: séparation pour dire que ca c'est la partie qui parle du mcCSA 
% TODO: expliquer qu'on utilise le concept de domination pour mcCSA et plus de
% fonction de cout comme plus haut

Définissons le concept de \textit{domination}
\cite{ConnectionScanAlgorithmLong:2017} : soient deux tuples $X = (x_1, \dots,
	x_n)$ et $Y = (y_1, \dots, y_n)$. Nous dirons que $X$ domine $Y$ si et
seulement si
\[
	\forall i \in \{1, \dots, n\},\ x_i \leq y_i \quad \land \quad \exists i \in \{1, \dots, n\},\ x_i < y_i.
\] \label{item:defDomination}

Sur base de~\hyperref[item:defDomination]{la définition de la domination}, nous
définissons le concept de \textit{pareto-optimal}
\cite{ConnectionScanAlgorithmLong:2017}: Soit $P$ un ensemble de tuples à
composantes scalaires, un tuple $x$ est pareto-optimal par rapport à $P$ s'il
n'existe aucun autre tuple $y \in P$ tel que $y$ domine $x$.\\

Nous pouvons appliquer~\hyperref[item:defDomination]{la définition de la
	domination} pour deux trajets arrivant au même arrêt $j1, j2$ en remplaçant
$x_1, \dots ,x_n$ et $y_1, \dots ,y_n$ par les valeurs pour chaque critère,
e.g. $x_1$ représente le nombre de connexions en tram du trajet $j1$, de même
pour $x_2$ mais pour le trajet $j2$.\\

Le mcCSA permet de résoudre le problème suivant :
\begin{quote}
	Étant donné l'horaire, un arrêt de départ $pDep$, un arrêt d'arrivée
	$pArr$, et un temps de départ $tDep$, et des critères de domination,
	renvoyer le sous-ensemble de trajets \textit{pareto-optimaux} par rapport
	aux critères de domination imposés par l'utilisateur et à l'ensemble de
	tous les trajets partant de $pDep$ à $tDep$ ou plus tard, et arrivant en
	$pArr$.
\end{quote}

Puisque nous construisons notre trajet en partant de l'arrivée, nous scannons
les connections par ordre de départ décroissant. À chaque étape de l'éxécution
de l'algorithme, pour chaque arrêt $p$, l'algorithme doit maintenir un
ensemble de trajets partiels $\mathcal{S}_p$ tel que :
\label{item:defProfileFunctionContent}
\[
	\forall j \in S_p, \quad \nexists j' \in S_p \text{ tel que } j'_{tDep} > j_{tDep} \text{ et } j' \text{ domine } j
\]
où :
\begin{itemize}
	\item $j_{tDep}$ désigne l'heure de départ du trajet $j$,
\end{itemize}

Nous appelons cet ensemble $S_p$ la \textit{fonction de profil} de
l'arrêt $p$. L'algorithme ajoute et supprime des trajets partiels (jusqu'à
destination) dans les fonctions de profil au fur et à mesure que celui-ci
scanne les connections dans l'ordre de départ décroissant. À chaque connexion
scannée $c$ nous tentons d'ajouter tous les trajets partiels qui peuvent être
effectués à partir de la connection $c$ dans la fonction de profile l'arrêt
$c_{pDep}$. Ceux dominés par un trajet partiel de $S_{c_{pDep}}$
partant en $tDep$ ou plus tard, ne sont pas gardés.\\

Afin de rendre le choix des critères de domination souple, nous introduisons la
notion de \texttt{CriteriaTracker}, une classe permettant de maintenir les
informations nécessaires à l'évaluation de tous les critères d'un trajet
partiel donné. Les fonctions de profile gardent pour chaque temps de départ de
trajets partiels, l'ensemble des trajets partiels concernés, chacun avec son
\texttt{CriteriaTracker} associé.
Lors de l'ajout des trajets partiels dans la fonction de profile de $c_{pDep}$,
seuls sont ajoutés les trajets partiels non-dominés par les trajets-partiels
partant en $c_{tDep}$ ou plus tard.\\

Notons que ~\hyperref[item:defProfileFunctionContent]{la définition du contenu
	d'une fonction de profil} nous autorise à conserver un trajet $j$ malgré le
fait que celui-ci soit dominé par un trajet $j'$ si l'heure de départ de $j'$
est antérieure à celle de $j$, c'est-à-dire~: $j'_{tDep} < j_{tDep}$

Nous devons conserver ces trajets car nous construisons les trajets en partant
du point d'arrivée~: Lorsque nous ajoutons un trajet $j$ dans la fonction de
profil de l'arrêt $p$, nous n'avons aucune garantie qu'une autre connexion
arrivant en $p$ et rendant la première connexion de $j$ atteignable existe.
Nous devons donc conserver des alternatives à $j$, partant plus tard, celles-ci
peuvent être dominées par $j$.\\

De plus, nous retirons les trajets partant avant $c_{tDep}$ qui sont dominés
par les trajets partiels que nous venons d'ajouter, car il est préfèrable
d'attendre et prendre ceux qui les dominent plutôt que de prendre ces trajets
partielles dominés.\\

Les trajets partiels que nous tentons d'ajouter à chaque connexion $c$ scannée
peuvent résulter de trois cas évalués
successivement~\cite{ConnectionScanAlgorithmLong:2017}. En effet l'utilisateur
n'a que trois possibilités pour continuer son trajet à partir de la connexion
$c$~:
\begin{enumerate}
	\item L'utilisateur peut sortir du véhicule et marcher jusqu'à la destination (s'il n'y est pas déjà).
	\item Il peut rester dans le même véhicule et prendre la prochaine connexion (si celle-ci existe).
	\item Il peut sortir du véhicule et rentrer dans un autre véhicule.
\end{enumerate}
% TODO: find a better way to reference 1a/b/c etc

Pour le cas 1, nous considérons un nouveau trajet partiel démarrant en $tDep$
dans $S_{cPdep}$, celui-ci contient un chemin (le chemin final), et une
connection. De plus, puisque ce chemin final fait partie d'un candidat, nous
ajoutons le trajet composé d'uniquement celui-ci dans la fonction de profile de
$S_{c_{pArr}}$.\\

Pour le cas 2, nous devons considérer les meilleurs trajets partiels pour
chaque \texttt{CriteriaTracker} (chaque combinaison de valeurs des différents
critères) empruntant la prochaine connexion de ce trip. Pour cela, nous
stockons dans $T$, pour chaque trip, ces meilleurs trajets. Celui-ci est mis à
jour après avoir considéré les trois cas.\\

Pour le cas 3, il faut envisager les meilleurs trajets que nous pouvons
effectuer à partir de $c_{pArr}$, à nouveau, pour chaque
\texttt{CriteriaTracker} (chaque combinaison de valeurs des différents
critères). C'est ce que nous appellons \textit{évaluer} $S_{c_{pArr}}$ au temps
$c_{tArr}$.\\

Nous regroupons les résultats de l'évaluation de ces trois cas. Pour ce faire,
si deux \texttt{CriteriaTracker} contiennent les mêmes valeurs des différents
critères, nous prenons le meilleur temps d'arrivée des deux trajets.
Ce groupe représente donc les meilleurs trajets possibles à partir de $c$.\\

Nous utilisons ce groupe pour mettre à jour l'entrée correspondant à
$c_{tripId}$ dans $T$, et nous insérons ces différents trajets partiels dans la
fonction de profile $S_{c_{pDep}}$, avec le temps de départ $c_{tDep}$.\\

Pour chaque cas, nous calculons les nouveaux \texttt{CriteriaTracker} (e.g.
ajouter un tram au compteur de trams).\\

Notre gestion du cas 1 ne permet que de gérer les chemins finaux, il reste nous
à gérer les autres chemins. Nous devonc donc considérer le cas où l'utilisateur
est arrivé au départ de $c$ en prenant un chemin.

Pour ce faire, pour chaque chemin qui arrive en $c_{pDep}$, nous reutilisons le
groupe des meilleurs trajets partiels et nous modifons chacun de ses
\texttt{CriteriaTracker} pour que ceux-ci tiennent compte du chemin arrivant en
$c_{pDep}$. Nous insérons chacun de ces groupes de meilleurs trajets partiels
modifiés dans la fonction de profile du chemin correspondant, avec le temps de
départ $c_{tDep} - f_{travelTime}$. Lorsqu'aucun trajet partiel n'a été gardé à
l'étape précédente (l'insertion dans des meilleurs trajets partiels dans la
fonction de profile $S_{c_{pDep}}$), cette étape-ci n'est pas nécessaire, car
tous ces trajets seront inévitablement aussi dominés. Cette optimization est
appelée \textit{limited walking}~\cite{ConnectionScanAlgorithmLong:2017}.
\\

Avec ceci et le cas 1, nous tenons compte de tous les chemins, excepté celui qui
relie directemment $pDep$ à $pArr$.\\

Il n'est nécessaire de distinguer le cas 2 du cas 3 que si des critères sont
liés aux trips, e.g. le nombre de transferts. Notre implémentation ne supporte
pas ce type de critères, celle-ci supporte seulement les critères liés aux
mouvements individuels (e.g. nombre de connexions en bus). Nous laissons donc
le code pour le cas 2 commenté, pour ne pas impacter les performances, et nous
ne tenons pas compte de celui-ci (et de $T$) pour la suite.\\

%-------------------------------------------------------------------

Une fois l'ensemble des connexions scannées, $S_{pDep}$ doit contenir
l'ensemble de tous les trajets partiels partant de $pDep$ en $tDep$ ou plus
tard, arrivant en $pArr$ et n'étant pas dominé par un autre trajet partant plus
tard. Connaissant notre heure de départ $tDep$, il suffit d'extraire de
$S_{pDep}$ tous les trajets non-dominés partant en $tDep$ ou plus tard. Nous ne
conservons donc plus les trajets qui sont dominés par d'autre tarjets partant
plus tôt. Nous pouvons les retirer car nous avons maintenant la certitude que
les meilleures alternatives sont atteignables puisque celles-ci démarrent en
$tDep$ ou après. (Nous n'avions pas encore cette certitude lorsque nous
construisions nos trajets partiels). Cet ensemble est le sous-ensemble de
trajets \textit{pareto-optimaux} par rapport aux critères de domination imposés
par l'utilisateur et à l'ensemble de tous les trajets partant de $pDep$ à
$tDep$ ou plus tard, et arrivant en $pArr$.\\

%-------------------------------------------------------------------
% section PseudoCode

%TODO: expliquer les différents trucs du pseudo code genre tauC etc

%TODO: enlever le mix francais anglais

%TODO: décrire les inputs de l'algorithme

Le pseudocode \autoref{alg:Solve} renvoie les fonctions de profil de tous les
arrêts, $S$, en considérant tous trajets arrivant en $pArr$ et empruntant
uniquement des connexions partant en $tDep$ ou plus tard. (Les trajets partant
d'autres arrêts différent de $pDep$ sont également pris en compte, car cet
algorithme est un algorithme \textit{all to one}, signifiant que celui-ci
résout pour tous les arrêts de départ).

\begin{algorithm}[H]
	\SetAlgoLined
	\DontPrintSemicolon
	\SetKwFunction{Solve}{solve}
	\SetKwProg{Fn}{Function}{:}{}

	\Fn{\Solve{$pArr$, $tDep$} \textbf{return} $S$}{

	initialiser Map $S$\;
	initialiser Map $D$\;

	\For{connexions $c$ par $c_{tDep}$ décroissant dans connexions partant après $tDep$}{

	initialiser Map $\tau_c$\;

	% Cas 1 : si la connexion arrive directement à la station d'arrivée
	\If{$c$ arrive en $p_{Arr}$}{
		initaliser newTracker et lui faire tenir compte de $c$\;
		mettre à jour $\tau_c$ avec (newTracker, $(c_{tArr}, c)$)\;
	}
	\Else{ % Cas 2 : sinon, il faut prendre un chemin à pied
	finalFootpath $\leftarrow D[c_{pArr}]$\;
	$\text{tArrWithFootpath} \leftarrow c_{tArr} + \text{finalFootpath}_{\text{travelTime}}$\;
	initaliser newTracker et lui faire tenir compte de $c$ et finalFootpath\;
	mettre à jour $\tau_c$ avec (newTracker, $(\text{tArrWithFootpath}, c)$)\;

	foopathTDep $\leftarrow c_{tArr}$ \;
	initaliser finalFootpathNewTracker et lui faire tenir compte de finalFootpath \;

	insérer (tArrWithFootpath, finalFootpath) au temps de départ foopathTDep, au tracker finalFootpathNewTracker, dans S[$c_{pArr}$]  \;
	}

	$\text{SCpArrEvaluatedAtCtArr} \leftarrow$ S[$c_{pArr}$] évalué en $c_{tArr}$ \;

	\For{trajetPartiel dans SCpArrEvaluatedAtCtArr}{
		$\text{newTracker} \leftarrow trajetPartiel_{tracker}~\text{qui tient compte de}~c$ \;
		mettre à jour $\tau_c$ avec (newTracker, $(trajetPartiel_{tArr}, c)$)\;
	}

	insérer tout $\tau_c$ au temps de départ $c_{tDep}$, dans S[$c_{pDep}$] \;
	$\text{auMoinsUnNonDominé} \leftarrow$ true si au moins un trajet partiel de $\tau_c$ a été gardé dans S[$c_{pDep}$] \;

	\If{auMoinsUnNonDominé}{

		$\text{SCpDepEvaluatedAtCtDep} \leftarrow$ S[$c_{pDep}$] évalué en $c_{tDep}$ \;

		\For{f dans chemins qui arrive en $c_{pDep}$}{
			$\text{fTDep} \leftarrow c_{tDep} - f_{travelTime}$ \;

			\For{trajetPartiel dans SCpDepEvaluatedAtCtDep}{
				$\text{newTracker} \leftarrow \text{trajetPartiel}_{CriteriaTracker}~\text{tenant compte de}~f$ \;
				insérer ($\text{trajetPartiel}_{tArr}, f$) au temps de départ fTDep, au tracker newTracker \;
			}
		}
	}
	}
    \Return{$S$}
	}

    \caption{Calcul de toutes les fonctions de profile pour une requête}
    \label{alg:Solve}
\end{algorithm}\\

Notons que, comme pour le CSA de base, nous pouvons à nouveau appliquer
l'optimisation~\hyperref[item:criteredepart]{\textit{critère de départ}}, c'est
pourquoi nous n'itérons pas sur toutes les connexions. Notons également que
$\tau_c$ correspond est la structure dans laquelle nous procédons au groupement
des trajets partiels empruntant $c$.

%-------------------------------------------------------------------
\subsection{Reconstruction de la solution}

Nous reconstruisons les différents trajets pareto-optimaux à l'aide des
\texttt{CriteriaTracker}, des fonctions de profile, et des temps de départ.

Considérons le trajet $j$ démarrant en $j_{tDep}$ de l'arrêt $j_{pDep}$ et
arrivant en $j_{pArr}$, composé des mouvements $m_1, \dots, m_n$. Notons $j_1,
	\dots, j_n$, les trajets partiels suffixes de $j$~: $j_i$ correspond au
sous-trajet partiel composé de $m_i, \dots, m_n$.\\

Pour tout sous-trajet $j_i$, connaissant
\begin{itemize}
	\item l'arrêt de départ $j_{i_{pDep}}$,
	\item le temps de départ $j_{i_{tDep}}$,
	\item $j_{i_{\text{CriteriaTracker}}}$, le CriteriaTracker en $j_{i_{pDep}}$
\end{itemize}
nous pouvons retrouver le prochain mouvement à emprunter $m_{i}$~: Il s'agit du
mouvement se trouvant dans $S_{j_{i_{pDep}}}$, partant de $j_{i_{pDep}}$ en
$j_{i_{tDep}}$ ou le plus tôt après, et dont le \texttt{CriteriaTracker} est
égal à $j_{i_{\text{CriteriaTracker}}}$. Cette étape est effectuée par la
procédure \texttt{getFirstMatch}.

Connaissant également le mouvement à emprunter $m_i$, nous pouvons déterminer~:
\begin{itemize}
	\item $j_{{i+1}_{pDep}} = m_{i_{pArr}}$

	\item \[
		      j_{{i+1}_{tDep}} = \left\{
		      \begin{array}{ll}
			      c_{tArr} \text{ si } m_i \text { est une connexion } c, \\
			      j_{{i-1}_{tDep}} + f_{travelTime} \text{ si } m_i \text{ est un chemin f.}
		      \end{array}
		      \right.
	      \]

	\item $j_{{i+1}_{\text{CriteriaTracker}}}$, en décrémentant le compteur de
	      bus/tram/train/metro/chemin de $j_{i_{\text{CriteriaTracker}}}$, en
	      fonction du type de mouvement de $m_i$.
\end{itemize}

Le cas de départ utilise le \texttt{CriteriaTracker} et le temps de départ du
trajet complet (partant de $pDep$) que nous voulons reconstruire. L'algorithme
s'arrête à l'étape à laquelle l'arrêt de départ du trajet partiel considéré est
l'arrêt de destination, c'est à dire quand $j_{i_{pDep}} = pArr$.\\

Le pseudocode \autoref{alg:DisplayJourney} illustre comment nous tirons parti
de cette induction pour reconstruire la solution.

\begin{algorithm}[H]
	\SetAlgoLined
	\DontPrintSemicolon
	\SetKwFunction{DisplayJourney}{displayJourney}
	\SetKwProg{Fn}{Function}{:}{}

	\Fn{\DisplayJourney{$S$, $pDepId$, $pArrId$, $tDep$, $criteriaTracker$}}{
		$stopId \leftarrow pDepId$\;

		\While{$stopId \neq pArrId$}{
			$movement \leftarrow S[stopId].\texttt{getFirstMatch}(tDep, criteriaTracker)$\;
			\texttt{print} ``taking'' $movement$\;

			$stopId \leftarrow movement.pArr.id$\;

			$criteriaTracker \leftarrow criteriaTracker~\text{ajusté en fonction du type de transport de}~movement$\;

			\eIf{$movement$ est un \texttt{Footpath}}{
				$tDep \leftarrow tDep + movement_{travelTime}$\;
			}{
				$tDep \leftarrow movement_{tArr}$\;
			}
		}
	}
	\caption{Reconstruction d'un trajet solution}
    \label{alg:DisplayJourney}
\end{algorithm}

\end{document}

% TODO: expliquer que vu que c'est un all-to-one, on pourrait supporter plusieurs arrêts de départ

%-------------------------------------------------------------------

\subsection{Structure de données}

Notre implémentation utilise principalement des \texttt{HashMap}, des
\texttt{ArrayList} et des \texttt{Pair}.


\begin{itemize}

	\item \texttt{HashMap<String, Stop> stopIdToStop}~: permet d’associer
	      l'identifiant d'un arrêt à l'objet \texttt{Stop}.

	\item \texttt{HashMap<String, List<Footpath>> stopIdToIncomingFootpaths}~:
	      associe à chaque arrêt une liste contenant les différentes instances de
	      \texttt{Footpath} qui arrivent de cet arrêt.

	\item \texttt{List<Connection> connections}~: liste des connexions triée
	      par heure de départ croissante.

	\item \texttt{Map<String, ProfileFunction> S}~: associe chaque arrêt à sa fonction de profile.

	\item \texttt{Map<String, Footpath> D}~: associe chaque arrêt au chemin partant de cet arrêt et arrivant à destination.
	      (Celui-ci est utilisé pour le cas 1, les chemins finaux).

\end{itemize}


\subsubsection{Fonction de profile}

La fonction de profile est composée d'un unique attribut~:
\texttt{ArrayList<Pair<Integer, HashMap<CriteriaTracker, Pair<Integer, Movement>>>> entries;}

Les paires se trouvant dans le \texttt{ArrayList} contiennent :
\begin{enumerate}
	\item Un temps de départ,
	\item Une map contenant les trajets partiels partant à ce temps de départ.
	      Cette map stocke les trajets partiels en associant à chaque
	      \texttt{CriteriaTracker}, une paire contenant~:
	      \begin{enumerate}
		      \item le temps d'arrivée de ce trajet partiel,
		      \item le prochain mouvement à emprunter pour suivre ce trajet,
	      \end{enumerate}
\end{enumerate}

Celles-ci sont ordonnées par temps de départ décroissant afin de maximiser le
nombre d'insertions en fin de liste (moins couteuses). Puisque nous scannons
les connexions par ordre de départ décroissant, nous allons généralement
insérer dans la fonction de profile des groupes de trajets partiels débutant de
plus en plus tôt. Nous ne pouvons pas garantir que cela est toujours de plus en
plus tôt à cause des chemins entre les arrêts~: Pour rappelle, pour chaque
chemin non-final, nous devons insérer nos trajets partiels empruntant $f$ suivi
d'une connexion $c$, au temps de départ $c_{tDep} - f_{travelTime}$. Ce temps
de départ pourrait être avant le départ de la prochaine connexion scannée
partant de $f_{pDep}$, appelons là $c'$. Dans ce cas, l'insertion dans le
profile de $S_{c'_{pDep}}$ ne sera pas en fin de liste car il existe déjà les
trajets partiels partant plus tôtdans le profile~: ceux partant en $c_{tDep} -
	f_{travelTime}$.\\


\bibliographystyle{plain}
\bibliography{refs}

\end{document}
