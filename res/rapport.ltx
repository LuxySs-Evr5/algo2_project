\documentclass{article}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[a4paper, margin=1in]{geometry}
\renewcommand{\familydefault}{\sfdefault}
\setlength{\parindent}{0pt}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{epigraph}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\lstset{
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  showstringspaces=false,
  breaklines=true,
  frame=single
}

\begin{document}

\begin{center}
	{\LARGE\textbf{INFO-F203 - Algorithmique 2 - Rapport}}\\[0.5em]
	\rule{0.9\textwidth}{1pt}
\end{center}

\vspace{5pt}
\begin{center}
	% \rowcolors{3}{green!25}{yellow!50}
	\begin{tabular}{ *3l }    \toprule
		\textbf{Prénom} & \textbf{Nom}      & \textbf{Matricule} \\\bottomrule
		Lucas           & Verbeiren         & 000591223          \\\bottomrule
		Ethan           & Van Ruyskensvelde & 000589640          \\\bottomrule
		%\hline
	\end{tabular}
\end{center}
\vspace{5pt}

\tableofcontents
\newpage

%-------------------------------------------------------------------

%TODO: remplacer l'adjectif basique (pas formel)

%TODO: parler du chargement des données
%TODO: parler du ballTree

%TODO: mentionner le fait qu'on a considéré que le temps de changement entre deux trips est 0s

%TODO: parler du fait que nos footpaths sont pas transitivement fermés en pratique en tout cas

\section{Introduction}

% TODO: par sûr du "au sens pareto"

% TODO: changer les verbes au futur "détaillerons" etc

Les transports en commun jouent un rôle central dans la mobilité en Belgique,
où de nombreux citoyens dépendent quotidiennement des bus, trams, métros et
trains pour se déplacer. Déterminer l’itinéraire le plus rapide entre deux
points constitue un enjeu crucial. Ce rapport présente deux variantes d’un
algorithme de plus court chemin prenant en compte les trajets multimodaux, i.e.
pouvant combiner différents modes de transport en commun. Celles-ci prennent
également en compte, des segments de marche à pied entre les arrêts. Les deux
algorithmes sont des variantes du Connection Scan Algorithm (CSA)
\cite{ConnectionScanAlgorithmLong:2017}. Dans un premier temps, nous détaillerons
le fonctionnement et notre implémentation du CSA basique qui optimise seulement
le temps d'arrivée. Dans un second temps, nous présenterons notre second
algorithme, une version légèrement modifiée du mcpCSA (où mc signifie
"multicritère" et p "profil") présenté dans
\cite{ConnectionScanAlgorithmLong:2017}. Ce dernier peut prendre en
considération d'autres critères et optimise ceux-ci au sens pareto.

%-------------------------------------------------------------------

\section{Principales classes et méthodes utilisées dans le programme java}

\begin{itemize}
	\item \textbf{Solver}~: classe principale contenant la logique de calcul du plus court chemin. Elle contient les méthodes
	      \begin{itemize}
		      \item \texttt{solve()}~: cœur de l’algorithme, calcule le plus court chemin à partir des données.

		      \item \texttt{reconstructSolution()} et \texttt{printInstructions()}~: reconstruisent le chemin optimal et affichent les instructions de trajet.

		      \item \texttt{loadData()} et \texttt{loadOneCsvSet()}~: chargent les différentes données des horaires et arrêts.
	      \end{itemize}

	\item \textbf{Connection}~: classe représentant un trajet direct entre deux arrêts, avec une heure de départ et d'arrivée ainsi que le point de départ et d'arrivée du trajet.

	\item \textbf{Footpath}~: représente un déplacement à pied entre deux arrêts proches avec le point de départ et d'arrivée.

	\item \textbf{Stop}~: représente un arrêt. Cette classe contient l’identifiant de l'arrêt, son nom et ses coordonnées géographiques.

	\item \textbf{Coord}~: représente des coordonnées géographiques et permet de calculer les distances à l’aide de la formule de \texttt{Haversine} pour la méthode \texttt{distanceTo()} qui détermine la distance entre deux \texttt{Coord}.

	\item \textbf{BestKnownEntry}~: associe à un arrêt le meilleur temps d’arrivée connu ainsi que l’action (trajet ou marche) permettant d’y parvenir.

	\item \textbf{Main}~: initialise un \texttt{Solver}, charge les différentes données grâce à la méthode \texttt{CsvSet()} et les passe au \texttt{Solver}, et essaie de trouver un plus court chemin entre deux arrêts à une heure de départ donnée.
\end{itemize}

%-------------------------------------------------------------------

\section{Chargement des données GTFS}

Avant que notre algorithme puisse déterminer le plus court chemin entre un arrêt de départ et un arrêt d'arrivée, notre programme doit d'abord charger les données nécessaires. Ces données, conformes au format \texttt{GTFS} (General Transit Feed Specification), contiennent toutes les informations liées aux arrêts, trajets, horaires et lignes de transport.\\

Les données GTFS utilisées dans notre programme sont les données publiques fournies par \texttt{DE LIJN}, la \texttt{STIB}, le \texttt{TEC} et la \texttt{SNCB}.\\

Le chargement des données est effectué via la fonction \texttt{loadOneCsvSet()} qui lit les fichiers suivants pour chaque opérateur :

\begin{itemize}
	\item \textbf{\texttt{stops.csv}} : contient les identifiants, noms et coordonnées géographiques des arrêts. Chaque arrêt est stocké dans une structure \texttt{Stop}, identifiée par son \texttt{stop\_id}.

	\item \textbf{\texttt{trips.csv}} : associe chaque \texttt{trip\_id} à une \texttt{route\_id}, représentant un parcours complet effectué par un véhicule.

	\item \textbf{\texttt{routes.csv}} : fournit le nom de chaque ligne, ainsi que le type de transport, et est identifiable grâce au \texttt{route\_id}. Ces données sont enregistrées dans une structure \texttt{RouteInfo} contenant toutes ces informations.

	\item \textbf{\texttt{stop\_times.csv}} : liste, pour chaque \texttt{trip}, les arrêts desservis dans l’ordre (\texttt{stop\_sequence}), avec l’heure de départ à chaque arrêt. Nous convertissons les horaires en secondes depuis minuit pour simplifier les comparaisons.
\end{itemize}

Une fois tous les fichiers lus, les informations sont regroupées en \textbf{connexions} représentant des trajets directs entre deux arrêts consécutifs d’un même trajet avec :
\begin{itemize}
	\item l’identifiant du trajet (\texttt{trip\_id}),
	\item la ligne de transport concernée (\texttt{RouteInfo}),
	\item l’arrêt de départ et d’arrivée (\texttt{Stop}),
	\item le temps de départ et le temps d’arrivée (en secondes).
\end{itemize}

Toutes les connexions ainsi générées sont ensuite triées par heure de départ croissante, ce qui permet à l’algorithme CSA de fonctionner efficacement lors de la recherche du plus court chemin.

\subsection{Construction des chemins à pied (\texttt{Footpath})}

Avant de pouvoir exécuter l'algorithme du plus court chemin, il est également nécessaire de construire les chemins à pied possibles (\texttt{Footpath}) entre arrêts proches. Pour notre programme, nous avons décidé de limiter la marche à pied à 500 mètres à vol d'oiseau. Ce chemin sera emprunté pour rejoindre un arrêt s'il est plus rapide ou nécessaire pour un changement de ligne.\\

Pour calculer ces \texttt{Footpath}, nous utilisons le \texttt{BallTree}. Celui-ci permet de réaliser des recherches de voisinage très rapides dans un espace à deux dimensions (latitude/longitude). Concrètement :

\begin{itemize}
	\item Tous les arrêts sont insérés dans un \texttt{BallTree}, avec leurs coordonnées GPS.
	\item Pour chaque arrêt, le \texttt{BallTree} est interrogé pour trouver les arrêts situés dans un rayon de 500 mètres.
	\item Un \texttt{Footpath} est alors créé entre l’arrêt source et chacun de ses voisins, avec une durée estimée basée sur une vitesse de marche moyenne (ici, 5 km/h).
\end{itemize}

Ces chemins à pied sont ensuite ajoutés à l’ensemble des connexions disponibles pour l’algorithme, au même titre que les trajets en transport en commun. Cela permet à l’utilisateur de combiner marche et transports publics pour atteindre sa destination le plus rapidement possible.

%-------------------------------------------------------------------

\section{CSA Basique}

Le CSA basique permet de résoudre le problème suivant :

\begin{quote}
	Étant donné l'horaire des véhicules, un arrêt de départ $pDep$, un arrêt d'arrivée
	$pArr$, et un temps de départ $tDep$, renvoyer les différents segments du trajets
	arrivant le plus tôt possible en $pArr$ en partant de $pDep$ en $tDep$.
\end{quote}

Notre version du CSA basique accepte des noms d’arrêts, qui ne sont pas
forcément uniques, au lieu des identifiants uniques. Elle considère tous les
arrêts correspondant au nom de départ et au nom d’arrivée, supposés proches les
uns des autres, et calcule le plus court trajet parmi ceux qui partent d’un des
arrêts de départ possibles et arrivent à un des arrêts d’arrivée possibles.

\subsection{Description de la structure de données utilisée}
Notre programme utilise principalement des \texttt{hashmaps}, des \texttt{listes} et une \texttt{pile} comme structures de données.

\begin{itemize}
	\item \texttt{HashMap<String, Stop> stopIdToStop}~: permet d’associer l'identifiant d'un stop à l'objet \texttt{Stop}.

	\item \texttt{HashMap<String, List<Footpath>> stopIdToOutgoingFootpaths}~: pour chaque arrêt, on garde une liste des chemins accessibles à pied.

	\item \texttt{List<Connection> connections}~: liste des connexions triée par heure de départ croissante.

	\item \texttt{Map<String, BestKnownEntry> bestKnown}~: permet de garder à
	      jour le meilleur temps d’arrivée connu pour chaque arrêt, ainsi que le
	      denier mouvement (trajet ou marche) qui nous y mène. Pour chaque arrêt,
	      si son identifiant unique est \texttt{stopId}, alors \texttt{bestKnown}
	      à l'entrée \texttt{stopId} peut se lire comme "nous parvenons en
	      \texttt{stopId} à l'instant \texttt{bestKnown.get(stopId).getTArr()} en
	      empruntant un trajet se terminant par
	      \texttt{bestKnown.get(stopId).getMovement()}".

	\item \texttt{Stack<BestKnownEntry>}~: utilisée pour reconstruire le chemin optimal, afin d'afficher les instructions dans l’ordre.
\end{itemize}

%-------------------------------------------------------------------

\subsection{Description de l'algorithme}

Dans cette section, nous définissons les différentes notions cruciales pour
comprendre l'algorithme, puis nous détaillons le fonctionnement de
l'algorithme \texttt{Connection Scan Algorithm (CSA) basique}.

%TODO: séparateur pour dire que ca c'est les notions importantes

\begin{itemize}

	\item Une connection est dite \textit{atteignable} si nous sommes en
	      mesures de nous trouver à son arrêt de départ au moment auquel celle-ci
	      ne démarre, i.e. $bestKnown_{tArr}(c_{pDep}) \leq c_{tDep}$.

	      %TODO: vérifier que ce truc est nécessaire à définir
	\item Un mouvement $m1$ est plus rapide qu'un autre mouvement $m2$ si $m1$
	      et $m2$ ont la même destination et $m1$ atteint celle-ci avant $m2$.
	      % TODO: expliquer ce qu'est un Movement

	\item Calcul du temps d'arrivé d'une chemin à pied : $f_{tArr} = f_{tDep} +
		      f_{travelTime}$ où $f_{tDep}$ correspond au meilleur temps connu pour se
	      rendre au point de départ de $f$, i.e. $f_{pDep}$.

\end{itemize}


%TODO: séparateur pour dire que ca c'est l'algo lui-meme


\begin{enumerate}

	\item \textbf{Critère de départ}~: \label{item:criteredepart}
	      \cite{ConnectionScanAlgorithmLong:2017} Aucune connection partant avant
	      le temps de départ demandé n'est \textit{atteignable}, il est donc
	      inutile de prendre celles-ci en compte dans la suite de l'algorithme.
	      La méthode\\ \texttt{getEarliestReachableConnectionIdx} détermine
	      l'indice de la première connection dont l’heure de départ est supérieur
	      ou égale à l’heure de départ demandée à l'aide d'une recherche
	      dichotomique dans \texttt{connections}.

	\item \textbf{Initialisation}~: Pour chaque arrêt de départ, nous
	      initialisons \texttt{bestKnown} aux entrées correspondantes comme suit:

	      \begin{itemize}

		      \item Le temps d'arrivée \texttt{tArr = tDep} : Nous pouvons nous y rendre
		            instantanément.

		      \item Le mouvement emprunté \texttt{movement = null} : Aucun mouvement n'est nécessaire pour s'y rendre.

	      \end{itemize}

	      Nous explorons également chaque chemin accessible à pied $f$ partant
	      de ces arrêts de départ. Si $f$ permet d'atteindre $f_{pArr}$ plus
	      rapidement que le meilleur temps connu pour atteindre celui-ci, i.e.
	      $f_{tArr} < bestKnown_{tArr}(f_{pArr})$, alors nous mettons à jour le
	      temps d'arrivée dans \texttt{bestKnown} à l'entrée $f_{pArr}$
	      comme-suit:

	      \begin{itemize}

		      \item Le temps d'arrivée \texttt{tArr =} $f_{tArr}$

		      \item Le mouvement emprunté \texttt{movement =} $f$

	      \end{itemize}

	\item \textbf{Scan des connections et chemins}~: Nous traitons les
	      \texttt{Connection} de \texttt{connections} itérativement, en ne tenant
	      compte que de celles partant à notre heure de départ ou après, i.e. à
	      partir de l'indice trouvé a
	      l'étape~\hyperref[item:criteredepart]{\textbf{Critère de départ}}.
	      Appelons la connection en cours de traitement $c$. (Pour rappelle, les
	      connexions sont triées par ordre croissant d’heure de départ, nous les
	      scannons donc dans ce même ordre) :

	      \begin{itemize}

		      \item si $c$ est \textit{atteignable}~,

		      \item et si $c$ permet d’arriver plus tôt à son arrêt d'arrivée $c_{pDep}$ que le meilleur temps connu pour s'y rendre à cette étape de l'algorithme~: $c_{tArr} < bestKnown_{tArr}(c_{pArr})$

		      \item Alors, nous mettons à jour l'entrée de \texttt{bestKnown}
		            correspondant à l’arrêt $c_{pArr}$ car nous venons de trouver
		            un moyen de s'y rendre plus rapidement.

		            Ensuite, pour chaque chemin $f$ sortant de $c_{pArr}$, nous
		            calculons le temps d'arrivée de ce chemin
		            $f_{tArr} = c_{tArr} + f_{travelTime}$.

		            Nous vérifions si $f$ nous permet d'atteindre son arrêt
		            d'arrivée $f_{pArr}$ plus rapidement que le meilleur temps
		            connu à cette étape de l'algorithme, i.e. $f_{tArr} <
			            bestKnown_{tArr}(f_{pArr})$
		            Si c'est le cas, nous mettons à jour bestKnown correspondant à $f_{pArr}$.

		            % TODO: expliquer pourquoi on a le droit de restreindre
		            % l'update les footpaths à seulement quand on a trouvé une
		            % meilleur connection (expliqué a la page 8: "Limited
		            % Walking")

	      \end{itemize}

	\item \textbf{Critère d'arrêt}~: Selon
	      \cite{ConnectionScanAlgorithmLong:2017}, nous pouvons arrêter
	      l'itération sur les connections dès que nous scannons une connection
	      $c$ telle que $c_{tDep} >= bestKnown_{tArr}(pArr)$.

	      Supposons $c$, la première connection telle que $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, comme $c_{tDep} < c_{tArr}$, si $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, alors par transitivé, nous avons que
	      $bestKnown_{tArr}(pArr) < c_{tArr}$. $c$ ne peut donc pas permettre
	      d'améliorer \texttt{bestKnown}.

	      Étant donné que nous scannons les connections par odre croissant, ces inégalité reste vraie pour toutes les connections après $c$.

	      Puisque notre algorithme supporte plusieurs arrêts d'arrivée avec le
	      même nom, et doit choissir celui auquel nous parvenons le plus
	      rapidement, nous devons tester cette inégalité pour chaque arrêt dont
	      le nom correspond au nom de la destination finale. Dès que cette
	      inégalité n'est plus vraie, nous pouvons arrêter le scan des
	      connections.

	\item \textbf{Recherche du meilleur arrêt d'arrivée}~: Puisque plusieurs
	      arrêts peuvent co-exister avec le même nom et que notre algorithme
	      prend en entrée un \textit{nom d'arrêt} de départ et d'arrivée et non
	      des identifiants d'arrêts uniques, nous cherchons l'identifiant unique
	      de l'arrêt d'arrivée auquel nous parvenons le plus rapidement, et ce
	      via une simple recherche linéaire.

	\item \textbf{Reconstruction}~: Une fois $pArr$ le meilleur arrêt d'arrivée
	      trouvé, nous reconstruisons, à partir de $pArr$, le trajet final
	      (chaque mouvement composant celui-ci) partant de $pDep$ en $tDep$ et
	      arrivant en $pArr$ le plus rapidement. Il s'agit d'un parcours en
	      postordre car nous le reconstruisons en partant du point d'arrivée.
	      Pour ce faire, nous utilisons donc une stack appelée
	      \texttt{finalPath}. Chaque `BestKnownEntry` (le mouvement et son temps
	      d'arrivée) est empilée sur \texttt{finalPath}. Une autre fonction
	      dépile ensuite la stack tout en affichant les différents segments du
	      trajet.

	      Comme pour les arrêts d'arrivée, plusieurs arrêts de départ
	      pourraient avoir un nom correspondant à celui entré par
	      l'utilisateur. Le cas de base de notre parcours en postordre est donc
	      le cas où le stop que nous regardons actuellement est un des
	      potentiels arrêts de départ.

	      \begin{algorithm}[H]
		      \DontPrintSemicolon
		      \SetAlgoLined

		      initialize empty stack $finalPath$ \;
		      $currentStopId \leftarrow pArrIdEarliest$ \;

		      \While{$currentStopId \notin pDepIds$}{
			      $currentEntry \leftarrow bestKnown[currentStopId]$ \;

			      empiler $currentEntry$ dans $finalPath$ \;
			      $currentStopId \leftarrow$ identifiant de l’arrêt de départ du mouvement de $currentEntry$ \;
		      }

		      \caption{Reconstruction du chemin optimal à partir de \texttt{bestKnown}}
	      \end{algorithm}

	      %TODO: parler de l'éventuelle dernière étape: print le trajet en dépilant

\end{enumerate}

%-------------------------------------------------------------------

\subsection{Preuve d'exactitude}

D'après ~\cite{critèresAlgoPlusCourtCheminDAG}, pour résoudre le problème du
plus court chemin (\textit{chemin} au sens théorie des graphes, correspondant
donc à un \textit{trajet} dans notre cas, à ne pas confondre avec les chemins
au sens instances de \texttt{Footpath}) dans un graphe dirigé acyclique, notre
algorithme doit :
\label{item:dagcriteresshortestpath}
\begin{itemize}

	\item Examiner les sommets dans un ordre topologique,

	\item{} Pour chaque sommet v, on assigne la valeur
	      $d(v) \leftarrow \min_{e=(u,v) \in \mathcal{E}} \{ d(u) + w(e) \}$

\end{itemize}

% ----- dirigé -----

D'abord, il est évident que notre graphe est dirigé. En effet, sans même tenir
compte des horaires, l'existence d'une connexion n'implique pas qu'il existe
une autre connexion effectuant le même trajet dans l'autre sens.\\

% ----- acyclic -----

Ensuite, montrons que ce graphe est acyclique, comme cela est mentionné dans
\cite{ConnectionScanAlgorithmShort}. Par l'absurde, supposons qu'il existe un
cycle formé de mouvements (formé de connexions et/ou chemins à pied) $m_1, m_2,
	\dots, m_n$ tels que:
\begin{itemize}

	\item $m_{n_{pArr}} = m_{1_{pArr}}$ : $m_n$ revient au point de départ du
	      cycle.

	\item L'ensemble de ces mouvements forme un chemin valide dans le réseau
	      (chaque connection est atteignable).

	\item Le départ de $m_1$ se fait à l'instant $t$ et l'arrivée de $m_n$ se
	      produit à l'instant $t'$.

\end{itemize}

%TODO: enlever les répétitions de "puisque" à chaque paragraphe

Puisque chaque connection peut être emprunté seulement si celle-ci est
atteignable, et que chaque movement prend un temps strictement positif, cela
implique que chaque transition de mouvement augmente strictement le temps. Donc
$t' > t$, ce qui contredit le fait que $m_1, \dots, m_n$ forme un cycle, car
certes, $m_n$ revient à l'arrêt de départ de $m_1$, mais du temps s'est écoulé
entre le moment auquel nous démarrons le cycle et celui auquel nous arrivons du
cycle. Certaines connexions qui étaient atteignable avant d'emprunter le cycle
ne sont donc potentiellement plus atteignables. \\

% -----------------------------

Puisque nous avons un graphe dirigé acyclique, il nous suffit de vérifier que
le CSA respecte bien les deux~\hyperref[item:dagcriteresshortestpath]{critères
	pour les algorithmes de plus court chemin dans un DAG}:

\begin{itemize}

	\item \textbf{Ordre topologique}~: \cite{tudelft} Puisque notre graphe est
	      un DAG, il existe forcément au moins un ordre topologique. Montrons
	      maintenant que parcourir les connexions par ordre de départ croissant
	      constitue un ordre topologique. Par l'absurde, supposons qu'il ne
	      s'agisse pas d'un ordre topologique. Cela signifie qu'il existe un
	      trajet $m_1, \dots, m_i$, et un autre trajet $m_i, \dot, m_n$ nous
	      permettant de reprendre $m_1$ au même moment que la fois précédente.
	      Clairement, cela entre directement en contradiction avec le fait que
	      les durées des mouvements sont strictement positives.

	\item \textbf{Relaxation des arêtes}~: Le second point est trivial, cela
	      correspond exactement à l'étape de relaxation des mouvements et de
	      mise-à-jour de \texttt{bestKnown}.

\end{itemize}

%-------------------------------------------------------------------

\subsection{Complexité}

% TODO complexité


%-------------------------------------------------------------------

\section{Pareto CSA Profile (multicritère)}

% TODO: "qui pourrait laisser penser" pas fou

% TODO: par sûr du "au sens pareto"

Dans cette section, nous présentons puis réfutons une idée intuitive selon
laquelle une simple modification du CSA basique permettrait d’en faire un
algorithme multicritère. Nous présentons ensuite notre implémentation modifiée
de l'algorithme mcpCSA qui peut prendre en compte plusieurs critères et
optimise ceux-ci au sens pareto.\\


Dans le CSA basique, la fonction de coût, nous renvoyant les couts placés dans \texttt{bestKnown}, se définit simplement par :
$$
	\operatorname{cost} : \mathbb{T} \to \mathbb{T}, \quad t \mapsto t
$$
C'est à dire que le cout est directemment le temps d'arrivée.\\

%TODO: pas convaincu par le C "complexe" ni par le fait qu'on passe de \mathbb{T} à \mathbb{C}

L'idée intuitive consiste alors à remplacer la fonction de coût par une
fonction déterminée par l'utilisateur, prenant en paramètre les valeurs pour
les critères supportés par le programme, e.g. le nombre de mouvements effectués
en trams : $$ \text{cost} : \mathbb{X}_1 \times \cdots \times \mathbb{X}_k \to
	\mathbb{C}, \quad (x_1, \ldots, x_k) \mapsto c $$ où $x_1, \ldots, x_k$
représentent des valeurs pour les critères choisis par l'utilisateur, e.g.
temps d'arrivée, nombre de connections en tram, nombre de chemins à pied, et $c
	\in \mathbb{C}$ est le coût global calculé selon la fonction définie par
l'utilisateur.

Nous ne stockerions alors plus simplement le temps d'arrivée dans
\texttt{bestKnown} mais $(x_1, \dots, x_n)$.
Afin d'effectuer la comparaison entre deux trajets $X, Y$ pour déterminer si
$X$ a un meilleur cout que $Y$, il de vérifier :
$$
	\operatorname{cost}(x_1, \dots, x_n) < \operatorname{cost}(y_1, \dots, y_n)
$$

Malheureusement, cette approche intuitive ne fonctionne par. Voici un
contre-exemple :

% TODO: écrire le contre-exmple avec tikz ou qqch de similaire



% Explication de "dominer", de "optimisation pareto"

% Expliauer pourquoi on peut pas juste remplacer la fonction de cout de l'algo
% précédent (le temps d'arrivée) par un nouvelle fonction qui tient compte du
% temps d'arrivée et de notre second critère.

% Expliquer l'autre algo:
% - Expliquer les notions de profile etc.
% - Expliquer pourquoi les final footpaths sont gérés différement des interstop footpaths


%-------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
