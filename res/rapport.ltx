\documentclass{article}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[a4paper, margin=1in]{geometry}
\renewcommand{\familydefault}{\sfdefault}
\setlength{\parindent}{0pt}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{epigraph}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\lstset{
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  showstringspaces=false,
  breaklines=true,
  frame=single
}

\begin{document}

\begin{center}
	{\LARGE\textbf{INFO-F203 - Algorithmique 2 - Rapport}}\\[0.5em]
	\rule{0.9\textwidth}{1pt}
\end{center}

\vspace{5pt}
\begin{center}
	% \rowcolors{3}{green!25}{yellow!50}
	\begin{tabular}{ *3l }    \toprule
		\textbf{Prénom} & \textbf{Nom}      & \textbf{Matricule} \\\bottomrule
		Lucas           & Verbeiren         & 000591223          \\\bottomrule
		Ethan           & Van Ruyskensvelde & 000589640          \\\bottomrule
		%\hline
	\end{tabular}
\end{center}
\vspace{5pt}

\tableofcontents
\newpage

%-------------------------------------------------------------------


%TODO: parler du chargement des données
%TODO: parler du ballTree

%TODO: mentionner le fait qu'on a considéré que le temps de changement entre deux trips est 0s

%TODO: parler du fait que nos footpaths sont pas transitivement fermés

\section{Introduction}

% TODO: par sûr du "au sens pareto"

Les transports en commun jouent un rôle central dans la mobilité en Belgique,
où de nombreux citoyens dépendent quotidiennement des bus, trams, métros et
trains pour se déplacer. Déterminer l’itinéraire le plus rapide entre deux
points constitue un enjeu crucial. Ce rapport présente deux variantes d’un
algorithme de plus court chemin prenant en compte les trajets multimodaux, i.e.
pouvant combiner différents modes de transport en commun. Celles-ci prennent
également en compte, des segments de marche à pied entre les arrêts. Les deux
algorithmes sont des variantes du Connection Scan Algorithm (CSA)
\cite{ConnectionScanAlgorithmLong:2017}. Dans un premier temps, nous détaillons
le fonctionnement et notre implémentation du CSA basique qui optimise seulement
le temps d'arrivée. Dans un second temps, nous présentons notre second
algorithme, une version légèrement modifiée du mcpCSA (où mc signifie
"multicritère" et p "profil") présenté dans
\cite{ConnectionScanAlgorithmLong:2017}. Ce dernier peut prendre en
considération d'autres critères et optimise ceux-ci au sens pareto.

%-------------------------------------------------------------------

\section{Principales classes et méthodes utilisées dans le programme java}

\begin{itemize}
	\item \textbf{Solver}~: classe principale contenant la logique de calcul du plus court chemin. Elle contient les méthodes
	      \begin{itemize}
		      \item \texttt{solve()}~: cœur de l’algorithme, calcule le plus court chemin à partir des données.

		      \item \texttt{reconstructSolution()} et \texttt{printInstructions()}~: reconstruisent le chemin optimal et affichent les instructions de trajet.

		      \item \texttt{loadData()} et \texttt{loadOneCsvSet()}~: chargent les différentes données des horaires et arrêts.
	      \end{itemize}

	\item \textbf{Connection}~: classe représentant un trajet direct entre deux arrêts, avec une heure de départ et d'arrivée ainsi que le point de départ et d'arrivée du trajet.

	\item \textbf{Footpath}~: représente un déplacement à pied entre deux arrêts proches avec le point de départ et d'arrivée.

	\item \textbf{Stop}~: représente un arrêt. Cette classe contient l’identifiant de l'arrêt, son nom et ses coordonnées géographiques.

	\item \textbf{Coord}~: représente des coordonnées géographiques et permet de calculer les distances à l’aide de la formule de \texttt{Haversine} pour la méthode \texttt{distanceTo()} qui détermine la distance entre deux \texttt{Coord}.

	\item \textbf{BestKnownEntry}~: associe à un arrêt le meilleur temps d’arrivée connu ainsi que l’action (trajet ou marche) permettant d’y parvenir.

	\item \textbf{Main}~: initialise un \texttt{Solver}, charge les différentes données grâce à la méthode \texttt{CsvSet()} et les passe au \texttt{Solver}, et essaie de trouver un plus court chemin entre deux arrêts à une heure de départ donnée.
\end{itemize}

%-------------------------------------------------------------------

\section{CSA Basique}

Le CSA basique permet de résoudre le problème suivant :

Étant donné l'horaire des véhicules, un arrêt de départ $pDep$, un arrêt d'arrivée
$pArr$, et un temps de départ $tDep$, renvoyer les différents segments du trajets
arrivant le plus tôt possible en $pArr$ en partant de $pDep$ en $tDep$.

Notre version du CSA basique accepte des noms d’arrêts, qui ne sont pas
forcément uniques, au lieu des identifiants uniques. Elle considère tous les
arrêts correspondant au nom de départ et au nom d’arrivée, supposés proches les
uns des autres, et calcule le plus court trajet parmi ceux qui partent d’un des
arrêts de départ possibles et arrivent à un des arrêts d’arrivée possibles.

\subsection{Description de la structure de données utilisée}
Notre programme utilise principalement des \texttt{hashmaps}, des \texttt{listes} et une \texttt{pile} comme structures de données.

\begin{itemize}
	\item \texttt{HashMap<String, Stop> stopIdToStop}~: permet d’associer l'identifiant d'un stop à l'objet \texttt{Stop}.

	\item \texttt{HashMap<String, List<Footpath>> stopIdToOutgoingFootpaths}~: pour chaque arrêt, on garde une liste des chemins accessibles à pied.

	\item \texttt{List<Connection> connections}~: liste des connexions triée par heure de départ croissante.

	\item \texttt{Map<String, BestKnownEntry> bestKnown}~: permet de garder à
	      jour le meilleur temps d’arrivée connu pour chaque arrêt, ainsi que le
	      denier mouvement (trajet ou marche) qui nous y mène. Pour chaque arrêt,
	      si son identifiant unique est \texttt{stopId}, alors \texttt{bestKnown}
	      à l'entrée \texttt{stopId} peut se lire comme "nous parvenons en
	      \texttt{stopId} à l'instant \texttt{bestKnown.get(stopId).getTArr()} en
	      empruntant un trajet se terminant par
	      \texttt{bestKnown.get(stopId).getMovement()}".

	\item \texttt{Stack<BestKnownEntry>}~: utilisée pour reconstruire le chemin optimal, afin d'afficher les instructions dans l’ordre.
\end{itemize}

%-------------------------------------------------------------------

\subsection{Description de l'algorithme}

Dans cette section, nous définissons les différentes notions cruciales pour
comprendre l'algorithme, puis nous détaillons le fonctionnement de
l'algorithme \texttt{Connection Scan Algorithm (CSA) basique}.

%TODO: séparateur pour dire que ca c'est les notions importantes

\begin{itemize}

	\item Une connection est dite \textit{atteignable} si nous sommes en
	      mesures de nous trouver à son arrêt de départ au moment auquel celle-ci
	      ne démarre, i.e. $bestKnown_{tArr}(c_{pDep}) \leq c_{tDep}$.

	      %TODO: vérifier que ce truc est nécessaire à définir
	\item Un mouvement $m1$ est plus rapide qu'un autre mouvement $m2$ si $m1$
	      et $m2$ ont la même destination et $m1$ atteint celle-ci avant $m2$.
	      % TODO: expliquer ce qu'est un Movement

	\item Calcul du temps d'arrivé d'une chemin à pied : $f_{tArr} = f_{tDep} +
		      f_{travelTime}$ où $f_{tDep}$ correspond au meilleur temps connu pour se
	      rendre au point de départ de $f$, i.e. $f_{pDep}$.

\end{itemize}


%TODO: séparateur pour dire que ca c'est l'algo lui-meme


\begin{enumerate}

	\item \textbf{Critère de départ}~: \label{item:criteredepart}
	      \cite{ConnectionScanAlgorithmLong:2017} Aucune connection partant avant
	      le temps de départ demandé n'est \textit{atteignable}, il est donc
	      inutile de prendre celles-ci en compte dans la suite de l'algorithme.
	      La méthode\\ \texttt{getEarliestReachableConnectionIdx} détermine
	      l'indice de la première connection dont l’heure de départ est supérieur
	      ou égale à l’heure de départ demandée à l'aide d'une recherche
	      dichotomique dans \texttt{connections}.

	\item \textbf{Initialisation}~: Pour chaque arrêt de départ, nous
	      initialisons \texttt{bestKnown} aux entrées correspondantes comme suit:

	      \begin{itemize}

		      \item Le temps d'arrivée \texttt{tArr = tDep} : Nous pouvons nous y rendre
		            instantanément.

		      \item Le mouvement emprunté \texttt{movement = null} : Aucun mouvement n'est nécessaire pour s'y rendre.

	      \end{itemize}

	      Nous explorons également chaque chemin accessible à pied $f$ partant
	      de ces arrêts de départ. Si $f$ permet d'atteindre $f_{pArr}$ plus
	      rapidement que le meilleur temps connu pour atteindre celui-ci, i.e.
	      $f_{tArr} < bestKnown_{tArr}(f_{pArr})$, alors nous mettons à jour le
	      temps d'arrivée dans \texttt{bestKnown} à l'entrée $f_{pArr}$
	      comme-suit:

	      \begin{itemize}

		      \item Le temps d'arrivée \texttt{tArr =} $f_{tArr}$

		      \item Le mouvement emprunté \texttt{movement =} $f$

	      \end{itemize}

	\item \textbf{Scan des connections et chemins}~: Nous traitons les
	      \texttt{Connection} de \texttt{connections} itérativement, en ne tenant
	      compte que de celles partant à notre heure de départ ou après, i.e. à
	      partir de l'indice trouvé a
	      l'étape~\hyperref[item:criteredepart]{\textbf{Critère de départ}}.
	      Appelons la connection en cours de traitement $c$. (Pour rappelle, les
	      connexions sont triées par ordre croissant d’heure de départ, nous les
	      scannons donc dans ce même ordre) :

	      \begin{itemize}

		      \item si $c$ est \textit{atteignable}~,

		      \item et si $c$ permet d’arriver plus tôt à son arrêt d'arrivée $c_{pDep}$ que le meilleur temps connu pour s'y rendre à cette étape de l'algorithme~: $c_{tArr} < bestKnown_{tArr}(c_{pArr})$

		      \item Alors, nous mettons à jour l'entrée de \texttt{bestKnown}
		            correspondant à l’arrêt $c_{pArr}$ car nous venons de trouver
		            un moyen de s'y rendre plus rapidement.

		            Ensuite, pour chaque chemin $f$ sortant de $c_{pArr}$, nous
		            calculons le temps d'arrivée de ce chemin
		            $f_{tArr} = c_{tArr} + f_{travelTime}$.

		            Nous vérifions si $f$ nous permet d'atteindre son arrêt
		            d'arrivée $f_{pArr}$ plus rapidement que le meilleur temps
		            connu à cette étape de l'algorithme, i.e. $f_{tArr} <
			            bestKnown_{tArr}(f_{pArr})$
		            Si c'est le cas, nous mettons à jour bestKnown correspondant à $f_{pArr}$.

		            % TODO: expliquer pourquoi on a le droit de restreindre
		            % l'update les footpaths à seulement quand on a trouvé une
		            % meilleur connection (expliqué a la page 8: "Limited
		            % Walking")

	      \end{itemize}

	\item \textbf{Critère d'arrêt}~: Selon
	      \cite{ConnectionScanAlgorithmLong:2017}, nous pouvons arrêter
	      l'itération sur les connections dès que nous scannons une connection
	      $c$ telle que $c_{tDep} >= bestKnown_{tArr}(pArr)$.

	      Supposons $c$, la première connection telle que $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, comme $c_{tDep} < c_{tArr}$, si $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, alors par transitivé, nous avons que
	      $bestKnown_{tArr}(pArr) < c_{tArr}$. $c$ ne peut donc pas permettre
	      d'améliorer \texttt{bestKnown}.

	      Étant donné que nous scannons les connections par odre croissant, ces inégalité reste vraie pour toutes les connections après $c$.

	      Puisque notre algorithme supporte plusieurs arrêts d'arrivée avec le
	      même nom, et doit choissir celui auquel nous parvenons le plus
	      rapidement, nous devons tester cette inégalité pour chaque arrêt dont
	      le nom correspond au nom de la destination finale. Dès que cette
	      inégalité n'est plus vraie, nous pouvons arrêter le scan des
	      connections.

	\item \textbf{Recherche du meilleur arrêt d'arrivée}~: Puisque plusieurs
	      arrêts peuvent co-exister avec le même nom et que notre algorithme
	      prend en entrée un \textit{nom d'arrêt} de départ et d'arrivée et non
	      des identifiants d'arrêts uniques, nous cherchons l'identifiant unique
	      de l'arrêt d'arrivée auquel nous parvenons le plus rapidement, et ce
	      via une simple recherche linéaire.

	\item \textbf{Reconstruction}~: Une fois $pArr$ le meilleur arrêt d'arrivée
	      trouvé, nous reconstruisons, à partir de $pArr$, le trajet final
	      (chaque mouvement composant celui-ci) partant de $pDep$ en $tDep$ et
	      arrivant en $pArr$ le plus rapidement. Il s'agit d'un parcours en
	      postordre car nous le reconstruisons en partant du point d'arrivée.
	      Pour ce faire, nous utilisons donc une stack appelée
	      \texttt{finalPath}. Chaque `BestKnownEntry` (le mouvement et son temps
	      d'arrivée) est empilée sur \texttt{finalPath}. Une autre fonction
	      dépile ensuite la stack tout en affichant les différents segments du
	      trajet.

	      Comme pour les arrêts d'arrivée, plusieurs arrêts de départ
	      pourraient avoir un nom correspondant à celui entré par
	      l'utilisateur. Le cas de base de notre parcours en postordre est donc
	      le cas où le stop que nous regardons actuellement est un des
	      potentiels arrêts de départ.

	      \begin{algorithm}[H]
		      \DontPrintSemicolon
		      \SetAlgoLined

		      initialize empty stack $finalPath$ \;
		      $currentStopId \leftarrow pArrIdEarliest$ \;

		      \While{$currentStopId \notin pDepIds$}{
			      $currentEntry \leftarrow bestKnown[currentStopId]$ \;

			      empiler $currentEntry$ dans $finalPath$ \;
			      $currentStopId \leftarrow$ identifiant de l’arrêt de départ du mouvement de $currentEntry$ \;
		      }

		      \caption{Reconstruction du chemin optimal à partir de \texttt{bestKnown}}
	      \end{algorithm}

	      %TODO: parler de l'éventuelle dernière étape: print le trajet en dépilant

\end{enumerate}


%-------------------------------------------------------------------

\section{Description des algorithmes et méthodes utilisées pour la variante du problème}

% Explication de "dominer", de "optimisation Pareto"

% Expliauer pourquoi on peut pas juste remplacer la fonction de cout de l'algo
% précédent (le temps d'arrivée) par un nouvelle fonction qui tient compte du
% temps d'arrivée et de notre second critère.

% Expliquer l'autre algo:
% - Expliquer les notions de profile etc.
% - Expliquer pourquoi les final footpaths sont gérés différement des interstop footpaths


%-------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
