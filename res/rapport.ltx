\documentclass{article}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[a4paper, margin=1in]{geometry}
\renewcommand{\familydefault}{\sfdefault}
\setlength{\parindent}{0pt}
\usepackage[table]{xcolor}
\usepackage{booktabs}
\usepackage{epigraph}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}
\lstset{
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  showstringspaces=false,
  breaklines=true,
  frame=single
}

\begin{document}

\begin{center}
	{\LARGE\textbf{INFO-F203 - Algorithmique 2 - Rapport}}\\[0.5em]
	\rule{0.9\textwidth}{1pt}
\end{center}

\vspace{5pt}
\begin{center}
	% \rowcolors{3}{green!25}{yellow!50}
	\begin{tabular}{ *3l }    \toprule
		\textbf{Prénom} & \textbf{Nom}      & \textbf{Matricule} \\\bottomrule
		Lucas           & Verbeiren         & 000591223          \\\bottomrule
		Ethan           & Van Ruyskensvelde & 000589640          \\\bottomrule
		%\hline
	\end{tabular}
\end{center}
\vspace{5pt}

\tableofcontents
\newpage

%-------------------------------------------------------------------

%TODO: remplacer l'adjectif basique (pas formel)

%TODO: parler du chargement des données
%TODO: parler du ballTree

%TODO: parler du fait que l'algo du CSA normal nous fait faire des switch inutiles

%TODO: mentionner le fait qu'on a considéré que le temps de changement entre deux trips est 0s

%TODO: parler du "limited walking optimization" et que ca a besoin que nos
%footpaths soient transitivement fermés + inégalité triangulaire ce qui en
%pratique n'est pas du tout le cas (voir https://arxiv.org/pdf/1703.05997 page 4)

\section{Introduction}

% TODO: par sûr du "au sens pareto"

% TODO: changer les verbes au futur "détaillerons" etc

Les transports en commun jouent un rôle central dans la mobilité en Belgique,
où de nombreux citoyens dépendent quotidiennement des bus, trams, métros et
trains pour se déplacer. Déterminer l’itinéraire le plus rapide entre deux
arrêts constitue un enjeu crucial. Ce rapport présente deux algorithmes de plus
court chemin prenant en compte les trajets multimodaux, i.e. pouvant combiner
différents modes de transport en commun. Ceux-ci prennent également en compte,
des segments de marche à pied entre les arrêts. Les deux algorithmes sont
regroupés sous le nom de \textit{Connection Scan Algorithm (CSA)} et sont
présentés dans \cite{ConnectionScanAlgorithmLong:2017}. Dans un premier temps,
nous expliquons les notions générales associées aux problèmes de plus court
chemin dans le contexte des
transports en commun. % TODO: il faut rajouter une section pour parler de ca
Dans un deuxième temps, nous détaillons le fonctionnement et notre
implémentation du CSA de base qui optimise seulement le temps d'arrivée
(\textit{earliest arrival CSA}). Dans un troisième temps, nous présentons une
version fortement insipirée du \textit{Pareto Connection Scan profile
	algorithm}. Ce dernier peut prendre en considération d'autres critères, en plus
du temps d'arrivée, et optimise ceux-ci au sens pareto.

%-------------------------------------------------------------------

\section{Principales classes et méthodes utilisées dans le programme java}

% TODO: virer les trucs spécifiques a un seul des algos et les mettre dans la
% section de l'algo correspondant. 

% TODO: ajouter Movement

\begin{itemize}
	\item \textbf{Solver}~: classe principale contenant la logique de calcul du plus court chemin. Elle contient les méthodes
	      \begin{itemize}
		      \item \texttt{solve()}~: cœur de l’algorithme, calcule le plus court chemin à partir des données.

		      \item \texttt{reconstructSolution()} et \texttt{printInstructions()}~: reconstruisent le chemin optimal et affichent les instructions de trajet.

		      \item \texttt{loadData()} et \texttt{loadOneCsvSet()}~: chargent les différentes données des horaires et arrêts.
	      \end{itemize}

	\item \textbf{Connection}~: classe représentant un trajet direct entre deux arrêts, avec une heure de départ et d'arrivée ainsi que le point de départ et d'arrivée du trajet.

	\item \textbf{Footpath}~: représente un déplacement à pied entre deux arrêts proches avec le point de départ et d'arrivée.

	\item \textbf{Stop}~: représente un arrêt. Cette classe contient l’identifiant de l'arrêt, son nom et ses coordonnées géographiques.

	\item \textbf{Coord}~: représente des coordonnées géographiques et permet de calculer les distances à l’aide de la formule de \texttt{Haversine} pour la méthode \texttt{distanceTo()} qui détermine la distance entre deux \texttt{Coord}.

	\item \textbf{BestKnownEntry}~: associe à un arrêt le meilleur temps d’arrivée connu ainsi que l’action (trajet ou marche) permettant d’y parvenir.

	\item \textbf{Main}~: initialise un \texttt{Solver}, charge les différentes données grâce à la méthode \texttt{CsvSet()} et les passe au \texttt{Solver}, et essaie de trouver un plus court chemin entre deux arrêts à une heure de départ donnée.
\end{itemize}

%-------------------------------------------------------------------

\section{Chargement des données GTFS}

Avant que notre algorithme puisse déterminer le plus court chemin entre un arrêt de départ et un arrêt d'arrivée, notre programme doit d'abord charger les données nécessaires. Ces données, conformes au format \texttt{GTFS} (General Transit Feed Specification), contiennent toutes les informations liées aux arrêts, trajets, horaires et lignes de transport.\\

Les données GTFS utilisées dans notre programme sont les données publiques fournies par \texttt{DE LIJN}, la \texttt{STIB}, le \texttt{TEC} et la \texttt{SNCB}.\\

Le chargement des données est effectué via la fonction \texttt{loadOneCsvSet()} qui lit les fichiers suivants pour chaque opérateur :

\begin{itemize}
	\item \textbf{\texttt{stops.csv}} : contient les identifiants, noms et coordonnées géographiques des arrêts. Chaque arrêt est stocké dans une structure \texttt{Stop}, identifiée par son \texttt{stop\_id}.

	\item \textbf{\texttt{trips.csv}} : associe chaque \texttt{trip\_id} à une \texttt{route\_id}, représentant un parcours complet effectué par un véhicule.

	\item \textbf{\texttt{routes.csv}} : fournit le nom de chaque ligne, ainsi que le type de transport, et est identifiable grâce au \texttt{route\_id}. Ces données sont enregistrées dans une structure \texttt{RouteInfo} contenant toutes ces informations.

	\item \textbf{\texttt{stop\_times.csv}} : liste, pour chaque \texttt{trip}, les arrêts desservis dans l’ordre (\texttt{stop\_sequence}), avec l’heure de départ à chaque arrêt. Nous convertissons les horaires en secondes depuis minuit pour simplifier les comparaisons.
\end{itemize}

Une fois tous les fichiers lus, les informations sont regroupées en \textbf{connexions} représentant des trajets directs entre deux arrêts consécutifs d’un même trajet avec :
\begin{itemize}
	\item l’identifiant du trajet (\texttt{trip\_id}),
	\item la ligne de transport concernée (\texttt{RouteInfo}),
	\item l’arrêt de départ et d’arrivée (\texttt{Stop}),
	\item le temps de départ et le temps d’arrivée (en secondes).
\end{itemize}

Une fois toutes les connexions générées à partir des données GTFS des différents opérateurs, il reste à trier toutes les connexions par heure de départ croissante, ce qui permet à l’algorithme CSA de fonctionner correctement lors de la recherche du plus court chemin.

\subsection{Construction des chemins à pied (\texttt{Footpath})}

Avant de pouvoir exécuter l'algorithme du plus court chemin, il est également nécessaire de construire les chemins à pied possibles (\texttt{Footpath}) entre arrêts proches. Pour notre programme, nous avons décidé de limiter la marche à pied à 500 mètres à vol d'oiseau. Ce chemin sera emprunté pour rejoindre un arrêt s'il est plus rapide ou nécessaire pour un changement de ligne.\\

Pour calculer ces \texttt{Footpath}, nous utilisons le \texttt{BallTree}. Celui-ci permet de réaliser des recherches de voisinage très rapides dans un espace à plusieurs dimensions (dans notre cas, deux : latitude/longitude). Concrètement, on procède ainsi :

\begin{itemize}
	\item Tous les arrêts sont insérés dans un \texttt{BallTree}, avec leurs coordonnées GPS.
	\item Pour chaque arrêt, le \texttt{BallTree} est interrogé pour trouver les arrêts situés dans un rayon de 500 mètres.
	\item Un \texttt{Footpath} est alors créé entre l’arrêt source et chacun de ses voisins, avec une durée estimée basée sur une vitesse de marche moyenne (ici, 5 km/h).
\end{itemize}

Ces chemins à pied sont ensuite ajoutés à l’ensemble des connexions disponibles pour l’algorithme, au même titre que les trajets en transport en commun. Cela permet à l’utilisateur de combiner marche et transports publics pour atteindre sa destination le plus rapidement possible.\\


% TODO: expliquer en quoi consiste la recherche naive des voisins
L'avantage du \texttt{BallTree} réside dans sa complexité de recherche : alors qu’une recherche naïve des voisins aurait une complexité en $\mathcal{O}(n^2)$, celle du \texttt{BallTree} est en $\mathcal{O}(n)$ dans le pire des cas, grâce à sa structure hiérarchique. Cette amélioration permet de rendre l’étape de génération des chemins à pied plus rapide.\\

%-------------------------------------------------------------------

\section{CSA Basique}

% TODO: expliquer la big flaw du CSA basique, comme on update seulement les
% footpaths directement connectés au connexions scannées, (on progpage pas plus
% qu'un seul footpath, jamais on propagera 2+ footpaths plus loin), ca repose
% sur le fait qu'on ne marche jamais 2 fois d'affilé. Cependant, cette
% condition est respectée uniquement si on a la fermeture transitive du graphe
% des footpaths, ce qui en pratique n'est pas le cas.

Le CSA basique permet de résoudre le problème suivant :

\begin{quote}
	Étant donné l'horaire des véhicules, un arrêt de départ $pDep$, un arrêt d'arrivée
	$pArr$, et un temps de départ $tDep$, renvoyer les différents segments du trajets
	arrivant le plus tôt possible en $pArr$ en partant de $pDep$ en $tDep$.
\end{quote}

Notre version du CSA basique accepte des noms d’arrêts, qui ne sont pas
forcément uniques, au lieu des identifiants uniques. Elle considère tous les
arrêts correspondant au nom de départ et au nom d’arrivée, supposés proches les
uns des autres, et calcule le plus court trajet parmi ceux qui partent d’un des
arrêts de départ possibles et arrivent à un des arrêts d’arrivée possibles.

\subsection{Description de la structure de données utilisée}
Notre programme utilise principalement des \texttt{hashmaps}, des \texttt{listes} et une \texttt{pile} comme structures de données.

\begin{itemize}
	\item \texttt{HashMap<String, Stop> stopIdToStop}~: permet d’associer l'identifiant d'un stop à l'objet \texttt{Stop}.

	\item \texttt{HashMap<String, List<Footpath>> stopIdToOutgoingFootpaths}~: pour chaque arrêt, on garde une liste des chemins accessibles à pied.

	\item \texttt{List<Connection> connections}~: liste des connexions triée par heure de départ croissante.

	\item \texttt{Map<String, BestKnownEntry> bestKnown}~: permet de garder à
	      jour le meilleur temps d’arrivée connu pour chaque arrêt, ainsi que le
	      denier mouvement (trajet ou marche) qui nous y mène. Pour chaque arrêt,
	      si son identifiant unique est \texttt{stopId}, alors \texttt{bestKnown}
	      à l'entrée \texttt{stopId} peut se lire comme "nous parvenons en
	      \texttt{stopId} à l'instant \texttt{bestKnown.get(stopId).getTArr()} en
	      empruntant un trajet se terminant par
	      \texttt{bestKnown.get(stopId).getMovement()}".

	\item \texttt{Stack<BestKnownEntry>}~: utilisée pour reconstruire le chemin optimal, afin d'afficher les instructions dans l’ordre.
\end{itemize}

%-------------------------------------------------------------------

\subsection{Description de l'algorithme}

Dans cette section, nous définissons les différentes notions cruciales pour
comprendre l'algorithme, puis nous détaillons le fonctionnement de
l'algorithme \texttt{Connection Scan Algorithm (CSA) basique}.

%TODO: séparateur pour dire que ca c'est les notions importantes

\begin{itemize}

	\item Une connection est dite \textit{atteignable} si nous sommes en
	      mesures de nous trouver à son arrêt de départ au moment auquel celle-ci
	      ne démarre, i.e. $bestKnown_{tArr}(c_{pDep}) \leq c_{tDep}$.

	      %TODO: vérifier que ce truc est nécessaire à définir
	\item Un mouvement $m1$ est plus rapide qu'un autre mouvement $m2$ si $m1$
	      et $m2$ ont la même destination et $m1$ atteint celle-ci avant $m2$.
	      % TODO: expliquer ce qu'est un Movement

	\item Calcul du temps d'arrivé d'une chemin à pied : $f_{tArr} = f_{tDep} +
		      f_{travelTime}$ où $f_{tDep}$ correspond au meilleur temps connu pour se
	      rendre au point de départ de $f$, i.e. $f_{pDep}$.

\end{itemize}


%TODO: séparateur pour dire que ca c'est l'algo lui-meme


\begin{enumerate}

	\item \textbf{Critère de départ}~: \label{item:criteredepart}
	      \cite{ConnectionScanAlgorithmLong:2017} Aucune connection partant avant
	      le temps de départ demandé n'est \textit{atteignable}, il est donc
	      inutile de prendre celles-ci en compte dans la suite de l'algorithme.
	      La méthode\\ \texttt{getEarliestReachableConnectionIdx} détermine
	      l'indice de la première connection dont l’heure de départ est supérieur
	      ou égale à l’heure de départ demandée à l'aide d'une recherche
	      dichotomique dans \texttt{connections}.

	\item \textbf{Initialisation}~: Pour chaque arrêt de départ, nous
	      initialisons \texttt{bestKnown} aux entrées correspondantes comme suit:

	      \begin{itemize}

		      \item Le temps d'arrivée \texttt{tArr = tDep} : Nous pouvons nous y rendre
		            instantanément.

		      \item Le mouvement emprunté \texttt{movement = null} : Aucun mouvement n'est nécessaire pour s'y rendre.

	      \end{itemize}

	      Nous explorons également chaque chemin accessible à pied $f$ partant
	      de ces arrêts de départ. Si $f$ permet d'atteindre $f_{pArr}$ plus
	      rapidement que le meilleur temps connu pour atteindre celui-ci, i.e.
	      $f_{tArr} < bestKnown_{tArr}(f_{pArr})$, alors nous mettons à jour le
	      temps d'arrivée dans \texttt{bestKnown} à l'entrée $f_{pArr}$
	      comme-suit:

	      \begin{itemize}

		      \item Le temps d'arrivée \texttt{tArr =} $f_{tArr}$

		      \item Le mouvement emprunté \texttt{movement =} $f$

	      \end{itemize}

	\item \textbf{Scan des connections et chemins}~: Nous traitons les
	      \texttt{Connection} de \texttt{connections} itérativement, en ne tenant
	      compte que de celles partant à notre heure de départ ou après, i.e. à
	      partir de l'indice trouvé a
	      l'étape~\hyperref[item:criteredepart]{\textbf{Critère de départ}}.
	      Appelons la connection en cours de traitement $c$. (Pour rappelle, les
	      connexions sont triées par ordre croissant d’heure de départ, nous les
	      scannons donc dans ce même ordre) :

	      \begin{itemize}

		      \item si $c$ est \textit{atteignable}~,

		      \item et si $c$ permet d’arriver plus tôt à son arrêt d'arrivée $c_{pDep}$ que le meilleur temps connu pour s'y rendre à cette étape de l'algorithme~: $c_{tArr} < bestKnown_{tArr}(c_{pArr})$

		      \item Alors, nous mettons à jour l'entrée de \texttt{bestKnown}
		            correspondant à l’arrêt $c_{pArr}$ car nous venons de trouver
		            un moyen de s'y rendre plus rapidement.

		            Ensuite, pour chaque chemin $f$ sortant de $c_{pArr}$, nous
		            calculons le temps d'arrivée de ce chemin
		            $f_{tArr} = c_{tArr} + f_{travelTime}$.

		            Nous vérifions si $f$ nous permet d'atteindre son arrêt
		            d'arrivée $f_{pArr}$ plus rapidement que le meilleur temps
		            connu à cette étape de l'algorithme, i.e. $f_{tArr} <
			            bestKnown_{tArr}(f_{pArr})$
		            Si c'est le cas, nous mettons à jour bestKnown correspondant à $f_{pArr}$.

		            % TODO: expliquer pourquoi on a le droit de restreindre
		            % l'update les footpaths à seulement quand on a trouvé une
		            % meilleur connection (expliqué a la page 8: "Limited
		            % Walking")

	      \end{itemize}

	\item \textbf{Critère d'arrêt}~: Selon
	      \cite{ConnectionScanAlgorithmLong:2017}, nous pouvons arrêter
	      l'itération sur les connections dès que nous scannons une connection
	      $c$ telle que $c_{tDep} >= bestKnown_{tArr}(pArr)$.

	      Supposons $c$, la première connection telle que $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, comme $c_{tDep} < c_{tArr}$, si $c_{tDep} >=
		      bestKnown_{tArr}(pArr)$, alors par transitivé, nous avons que
	      $bestKnown_{tArr}(pArr) < c_{tArr}$. $c$ ne peut donc pas permettre
	      d'améliorer \texttt{bestKnown}.

	      Étant donné que nous scannons les connections par odre croissant, ces inégalité reste vraie pour toutes les connections après $c$.

	      Puisque notre algorithme supporte plusieurs arrêts d'arrivée avec le
	      même nom, et doit choissir celui auquel nous parvenons le plus
	      rapidement, nous devons tester cette inégalité pour chaque arrêt dont
	      le nom correspond au nom de la destination finale. Dès que cette
	      inégalité n'est plus vraie, nous pouvons arrêter le scan des
	      connections.

	\item \textbf{Recherche du meilleur arrêt d'arrivée}~: Puisque plusieurs
	      arrêts peuvent co-exister avec le même nom et que notre algorithme
	      prend en entrée un \textit{nom d'arrêt} de départ et d'arrivée et non
	      des identifiants d'arrêts uniques, nous cherchons l'identifiant unique
	      de l'arrêt d'arrivée auquel nous parvenons le plus rapidement, et ce
	      via une simple recherche linéaire.

	\item \textbf{Reconstruction}~: Une fois $pArr$ le meilleur arrêt d'arrivée
	      trouvé, nous reconstruisons, à partir de $pArr$, le trajet final
	      (chaque mouvement composant celui-ci) partant de $pDep$ en $tDep$ et
	      arrivant en $pArr$ le plus rapidement. Il s'agit d'un parcours en
	      postordre car nous le reconstruisons en partant du point d'arrivée.
	      Pour ce faire, nous utilisons donc une stack appelée
	      \texttt{finalPath}. Chaque `BestKnownEntry` (le mouvement et son temps
	      d'arrivée) est empilée sur \texttt{finalPath}. Une autre fonction
	      dépile ensuite la stack tout en affichant les différents segments du
	      trajet.

	      Comme pour les arrêts d'arrivée, plusieurs arrêts de départ
	      pourraient avoir un nom correspondant à celui entré par
	      l'utilisateur. Le cas de base de notre parcours en postordre est donc
	      le cas où le stop que nous regardons actuellement est un des
	      potentiels arrêts de départ.

	      \begin{algorithm}[H]
		      \DontPrintSemicolon
		      \SetAlgoLined

		      initialize empty stack $finalPath$ \;
		      $currentStopId \leftarrow pArrIdEarliest$ \;

		      \While{$currentStopId \notin pDepIds$}{
			      $currentEntry \leftarrow bestKnown[currentStopId]$ \;

			      empiler $currentEntry$ dans $finalPath$ \;
			      $currentStopId \leftarrow$ identifiant de l’arrêt de départ du mouvement de $currentEntry$ \;
		      }

		      \caption{Reconstruction du chemin optimal à partir de \texttt{bestKnown}}
	      \end{algorithm}

	      %TODO: parler de l'éventuelle dernière étape: print le trajet en dépilant

\end{enumerate}

%-------------------------------------------------------------------

\subsection{Preuve d'exactitude}

D'après ~\cite{critèresAlgoPlusCourtCheminDAG}, pour résoudre le problème du
plus court chemin (\textit{chemin} au sens théorie des graphes, correspondant
donc à un \textit{trajet} dans notre cas, à ne pas confondre avec les chemins
au sens instances de \texttt{Footpath}) dans un graphe dirigé acyclique, notre
algorithme doit :
\label{item:dagcriteresshortestpath}
\begin{itemize}

	\item Examiner les sommets dans un ordre topologique,

	\item{} Pour chaque sommet v, on assigne la valeur
	      $d(v) \leftarrow \min_{e=(u,v) \in \mathcal{E}} \{ d(u) + w(e) \}$

\end{itemize}

% ----- dirigé -----

D'abord, il est évident que notre graphe est dirigé. En effet, sans même tenir
compte des horaires, l'existence d'une connexion n'implique pas qu'il existe
une autre connexion effectuant le même trajet dans l'autre sens.\\

% ----- acyclic -----

Ensuite, montrons que ce graphe est acyclique, comme cela est mentionné dans
\cite{ConnectionScanAlgorithmShort}. Par l'absurde, supposons qu'il existe un
cycle formé de mouvements (formé de connexions et/ou chemins à pied) $m_1, m_2,
	\dots, m_n$ tels que:
\begin{itemize}

	\item $m_{n_{pArr}} = m_{1_{pArr}}$ : $m_n$ revient au point de départ du
	      cycle.

	\item L'ensemble de ces mouvements forme un chemin valide dans le réseau
	      (chaque connection est atteignable).

	\item Le départ de $m_1$ se fait à l'instant $t$ et l'arrivée de $m_n$ se
	      produit à l'instant $t'$.

\end{itemize}

%TODO: enlever les répétitions de "puisque" à chaque paragraphe

Puisque chaque connection peut être emprunté seulement si celle-ci est
atteignable, et que chaque movement prend un temps strictement positif, cela
implique que chaque transition de mouvement augmente strictement le temps. Donc
$t' > t$, ce qui contredit le fait que $m_1, \dots, m_n$ forme un cycle, car
certes, $m_n$ revient à l'arrêt de départ de $m_1$, mais du temps s'est écoulé
entre le moment auquel nous démarrons le cycle et celui auquel nous arrivons du
cycle. Certaines connexions qui étaient atteignable avant d'emprunter le cycle
ne sont donc potentiellement plus atteignables. \\

% -----------------------------

Puisque nous avons un graphe dirigé acyclique, il nous suffit de vérifier que
le CSA respecte bien les deux~\hyperref[item:dagcriteresshortestpath]{critères
	pour les algorithmes de plus court chemin dans un DAG}:

\begin{itemize}

	\item \textbf{Ordre topologique}~: \cite{tudelft} Puisque notre graphe est
	      un DAG, il existe forcément au moins un ordre topologique. Montrons
	      maintenant que parcourir les connexions par ordre de départ croissant
	      constitue un ordre topologique. Par l'absurde, supposons qu'il ne
	      s'agisse pas d'un ordre topologique. Cela signifie qu'il existe un
	      trajet $m_1, \dots, m_i$, et un autre trajet $m_i, \dot, m_n$ nous
	      permettant de reprendre $m_1$ au même moment que la fois précédente.
	      Clairement, cela entre directement en contradiction avec le fait que
	      les durées des mouvements sont strictement positives.

	\item \textbf{Relaxation des arêtes}~: Le second point est trivial, cela
	      correspond exactement à l'étape de relaxation des mouvements et de
	      mise à jour de \texttt{bestKnown}.

\end{itemize}

%-------------------------------------------------------------------

\subsection{Complexité}

% TODO complexité


%-------------------------------------------------------------------

\section{CSA multicritère}

% TODO: check le casing de $x$ et $y$

% TODO: petite partie qui décrit le probleme du multicritère, en quoi ca
% consiste un peu comme l'intro du CSA normale, il faut au moins dire qu'on
% part de pDep en tDep et qu'on arrive en pArr

% TODO: "qui pourrait laisser penser" pas fou

% TODO: par sûr du "au sens pareto"

Dans cette section, nous présentons puis réfutons une idée intuitive selon
laquelle une simple modification du CSA basique permettrait d’en faire un
algorithme multicritère. Nous présentons ensuite notre implémentation modifiée
de l'algorithme mcpCSA qui peut prendre en compte plusieurs critères et
optimise ceux-ci au sens pareto.\\


Dans le CSA basique, la fonction de coût, utilisée pour comparer deux trajets
lors de la mise à jour de \texttt{bestKnown}, est définie par :
\[
	\operatorname{cost} : \mathbb{T} \to \mathbb{T}, \quad t \mapsto t
\]
C'est à dire que le cout est directemment le temps d'arrivée.\\

%TODO: pas convaincu par le C "complexe" ni par le fait qu'on passe de \mathbb{T} à \mathbb{C}

L'idée intuitive consiste alors à remplacer la fonction de coût par une
fonction déterminée par l'utilisateur, prenant en paramètre les valeurs pour
les critères supportés par le programme, e.g. le nombre de mouvements effectués
en trams :
\[
	\text{cost} : \mathbb{X}_1 \times \cdots \times \mathbb{X}_n \to
	\mathbb{C}, \quad (x_1, \ldots, x_n) \mapsto c
\] \label{item:CostMultiCriteria}
où
\begin{itemize}

	\item $x_1, \ldots, x_n$ représentent des valeurs pour les critères choisis
	      par l'utilisateur, e.g. temps d'arrivée, nombre de connections en tram,
	      nombre de chemins à pied.

	\item $c \in \mathbb{C}$ est le coût global calculé selon la fonction
	      définie par l'utilisateur.

\end{itemize}

Nous conservons alors dans \texttt{bestKnown}, pour chaque arrêt, les $x_1,
	\ldots, x_n$ correspondant au trajet menant à cet arrêt et minimisant le coût.

Afin d'effectuer la comparaison entre deux trajets $X, Y$ pour déterminer si
$X$ a un meilleur cout que $Y$, il suffit de vérifier :
\[
	\operatorname{cost}(x_1, \dots, x_n) < \operatorname{cost}(y_1, \dots, y_n)
\]

Malheureusement, cette approche intuitive ne fonctionne pas. Voici un
contre-exemple :

\begin{center}
	\begin{tikzpicture}[->, >=Stealth, node distance=1cm, thick]

		% Nodes
		\node[circle, draw] (x) at (0,2)  {$x$};
		\node[circle, draw] (w) at (0,0)  {$w$};
		\node[circle, draw] (y) at (3,2)  {$y$};
		\node[circle, draw] (z) at (5.5,2)  {$z$};

		% Edges
		\draw (x) -- (y) node[midway, xshift=25pt, yshift=6pt] {$t2$};
		\draw (x) -- (y) node[midway, xshift=-27pt, yshift=6pt] {$t1$};
		\draw (x) -- (y) node[midway, xshift=-3pt, yshift=5pt] {$c1$};

		\draw (w) -- (y) node[midway, xshift=27pt, yshift=11pt] {$t4$};
		\draw (w) -- (y) node[midway, xshift=-33pt, yshift=-14pt] {$t3$};
		\draw (w) -- (y) node[midway, xshift=3pt, yshift=-3pt] {$c3$};

		\draw (y) -- (z) node[midway, xshift=-22pt, yshift=6pt] {$t2$};
		\draw (y) -- (z) node[midway, xshift=0pt, yshift=6pt] {$c2$};

	\end{tikzpicture}
\end{center}

% TODO: qqch pour expliquer ce qui est quoi dans ce graphe, expliquer que t1<t2<t3<t4

Notons pour toute connection $c$:
\[
	\operatorname{cost}(c) = \operatorname{cost}(pDep \rightarrow c_{pDep} + c)
\]

Autrement dit, le coût
d'une connexion $c$ correspond au coût du trajet composé du meilleur itinéraire
partant d'un point de départ spécifié par l’utilisateur, atteignant $c_{pDep}$,
puis empruntant la connexion $c$.\\

% TODO: fix les temps pour qu'il match le graphe
Étant donné que $c1_{tDep} < c2_{tDep} < c3_{tdep}$, nous scannons d'abord $c1$.
% TODO: améliorer cette phrase
Une fois le scan de $c1$ terminé :
\[
	\texttt{bestKnown}_{cost}(y) \leq \operatorname{cost}(c1)
\]

Il en va de même pour le scan de $c2$ :
\[
	\texttt{bestKnown}_{cost}(z) \leq \operatorname{cost}(c2)
\]

Et enfin, nous scannons la connection $c3$.
Supposons que:
\[
	\texttt{bestKnown}_{cost}(z) > \operatorname{cost}(c3)
\]

Nous remplaçons alors les $x_1, \dots, x_n$ (aini que l'instance de
\texttt{Movement}) dans \texttt{bestKnown} pour l'arrêt $y$.

Cette décision rend notre solution partielle invalide, car en prenant $c3$ qui
arrive en $y$ à l'instant $t4$, nous ne pouvons plus atteindre $c2$ qui part de
$y$ en $t2$.\\

% TODO: check si ca serait pas mieux d'expliquer ca avant de mettre le
% contre-exemple
Formellement, cela est dû fait que seul le critère de temps d'arrivée le plus
tôt respecte \textit{la condition d'échangeabilité préfixe} :
\cite{ConnectionScanAccelerated} Soit $s_1, s_2, \dots, s_n$ un trajet optimal
$A@tDep \rightarrow B$, i.e. partant de $A$ en $tDep$ et arrivant en $B$.
Considérons un préfixe quelconque $s_1, \dots, s_i$, un trajet complet arrivant
en $C$. Remplacer le préfixe par un autre trajet optimal $A@tDep \rightarrow C$
doit donner un autre trajet optimal $A@tDep \rightarrow B$. Cependant, seul le
critère d'arrivée le plus tôt satisfait cette propriété.\\

Similairement nous pouvons définir la \textit{condition d'échangeabilité
	suffixe} \cite{ConnectionScanAccelerated} : Soit $s_1, \dots, s_n$ un trajet
optimal $A@\tau \rightarrow B$. Considérons n'importe quel suffixe $s_i, \dots,
	s_n$ qui est un trajet complet partant de $C$ en $\tau'$. Remplacer ce suffixe
par un autre trajet optimal $C@\tau' \rightarrow B$ doit donner un autre trajet
optimal.\\

Étant donné que cette seconde condition est maintenue par les
~\hyperref[item:CostMultiCriteria]{fonctions de coût multicritères}, nous en
tirons avantage pour notre algorithme en construisant les trajets à partir du
point d'arrivée \cite{ConnectionScanAccelerated}.\\

% TODO: séparation pour dire que ca c'est la partie qui parle du mcCSA


Définissons le concept de \textit{domination}
\cite{ConnectionScanAlgorithmLong:2017}: soient deux tuples $X = (x_1, \dots,
	x_n)$ et $Y = (y_1, \dots, y_n)$. Nous dirons que $X$ domine $Y$ si et
seulement si :
\[
	\forall i \in \{1, \dots, n\},\ x_i \leq y_i \quad \land \quad \exists i \in \{1, \dots, n\},\ x_i < y_i.
\] \label{item:defDomination}

Sur base de~\hyperref[item:defDomination]{la définition de la domination}, nous
définissons le concept de \textit{pareto-optimal}
\cite{ConnectionScanAlgorithmLong:2017}: Soit $P$ un ensemble de tuples à
composantes scalaires, un tuple $x$ est pareto-optimal par rapport à $P$ s'il
n'existe aucun autre tuple $y \in P$ tel que $y$ domine $x$.\\

Nous pouvons appliquer~\hyperref[item:defDomination]{la définition de la
	domination} pour deux trajets arrivant au même arrêt $j1, j2$ en remplaçant
$x_1, \dots ,x_n$ et $y_1, \dots ,y_n$ par les valeurs pour chaque critère,
e.g. $x_1$ représente le nombre de connexions en tram du trajet $j1$, de même
pour $x_2$ mais pour le trajet $j2$.\\

Le mcCSA permet de rśoudre le problème suivant :
\begin{quote}
	Étant donné l'horaire des véhicules, un arrêt de départ $pDep$, un arrêt
	d'arrivée $pArr$, et un temps de départ $tDep$, renvoyer le sous-ensemble
	de trajets \textit{pareto-optimaux} par rapport à l'ensemble de tous les
	trajets partant de $pDep$ à $tDep$ ou plus tard, et arrivant en $pArr$.
\end{quote}

% TODO: c'est bcp plus compliqué que ca car on doit garder tout ce qui part
% plus tard

Puisque nous construisons notre trajet en partant de l'arrivée, nous scannons
les connections par ordre de départ décroissant. À tout instant de l'éxécution
de l'algorithme, pour chaque arrêt $p$, l'algorithme doit déterminer un
ensemble $\mathcal{S}_p$ de trajets tel que :
\label{item:defProfileFunctionContent}
\[
	\forall j \in \mathcal{S}_p, \quad \nexists j' \in \mathcal{S}_p \text{ tel que } j'_{tDep} > j_{tDep} \text{ et } j' \text{ domine } j
\]
où :
\begin{itemize}
	\item $j_{tDep}$ désigne l'heure de départ du trajet $j$,
\end{itemize}

Nous appelons cet ensemble $\mathcal{S}_p$ la \textit{fonction de profil} de
l'arrêt $p$. L'algorithme ajoute et supprime des trajets partiels dans les
fonctions de profil au fur et à mesure que celui-ci scanne les connections.\\

Notons que ~\hyperref[item:defProfileFunctionContent]{la définition du contenu
	d'une fonction de profil} nous autorise à conserver un trajet $j$ malgré le
fait que celui-ci soit dominé par un trajet $j'$ si l'heure de départ de $j'$
est antérieure à celle de $j$, c'est-à-dire : $j'_{tDep} < j_{tDep}$\\

%TODO: changer le "est du au fait que"

Nous devons conserver ces trajets car nous construisons les trajets en partant
du point d'arrivée : Lorsque nous ajoutons un trajet $j$ dans la fonction de
profil de l'arrêt $p$, nous n'avons aucune garantie qu'une autre connexion
arrivant en $p$ et rendant la première connexion de $j$ atteignable existe.
Nous devons donc conserver des alternatives à $j$, partant plus tard, celles-ci
peuvent être dominées par $j$.


% - Expliquer à quoi sert et comment est implémentée une profile function
% - Expliquer "dominer" "optimisation pareto"
% - Expliquer pourquoi les final footpaths sont gérés différement des interstop footpaths
% - Parler du fait qu'on peut à nouveau faire l'opti de "critère de départ"


%-------------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
